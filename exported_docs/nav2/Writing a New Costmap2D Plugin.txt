Title: Writing a New Costmap2D Plugin
URL: https://docs.nav2.org/plugin_tutorials/docs/writing_new_costmap2d_plugin.html#overview
Section: getting_started/index.html
--------------------------------------------------------------------------------


## Overview
This tutorial shows how to create your own simplepluginfor Costmap2D.
Before starting the tutorial, please check thisvideowhich contains information about Costmap2D layers design and plugins basic operational principals.

## Requirements
It is assumed that ROS 2, Gazebo and TurtleBot3 packages are installed or built locally. Please make sure that Nav2 project is also built locally as it was made inBuild and Install.

## Tutorial Steps


## 1- Write a new Costmap2D plugin
For a demonstration, this example will create a costmap plugin that puts repeating cost gradients in the costmap.
The annotated code for this tutorial can be found innavigation2_tutorialsrepository as thenav2_gradient_costmap_pluginROS 2-package.
Please refer to it when making your own layer plugin for Costmap2D.
The plugin classnav2_gradient_costmap_plugin::GradientLayeris inherited from basic classnav2_costmap_2d::Layer:
The basic class provides the set of virtual methods API for working with costmap layers in a plugin. These methods are called at runtime byLayeredCostmap. The list of methods, their description, and necessity to have these methods in plugin’s code is presented in the table below:
In our example these methods have the following functionality:
and setsneed_recalculation_bounds recalculation indicator:
where theGRADIENT_SIZEis the size of each gradient period in map cells,GRADIENT_FACTOR- decrement of costmap’s value per each step:
These parameters are defined in plugin’s header file.

## 2- Export and make GradientLayer plugin
The written plugin will be loaded at runtime as its basic parent class and then will be called by plugin handling modules (for costmap2d byLayeredCostmap). Pluginlib opens a given plugin in run-time and provides methods from exported classes to be callable. The mechanism of class exporting tells pluginlib which basic class should be used during these calls. This allows to extend an application by plugins without knowing application source code or recompiling it.
In our example thenav2_gradient_costmap_plugin::GradientLayerplugin’s class should be dynamically loaded as anav2_costmap_2d::Layerbasic class. For this the plugin should be registered as follows:
This part is usually placed at the end of cpp-file where the plugin class was written (in our examplegradient_layer.cpp). It is good practice to place these lines at the end of the file, but technically, you can also place at the top.
The export of plugin is performed by includingpluginlib_export_plugin_description_file()cmake-function intoCMakeLists.txt. This function installs plugin description file intosharedirectory and sets ament indexes for plugin description XML to be discoverable as a plugin of selected type:
Plugin description file is also should be added topackage.xml.costmap_2dis the package of the interface definition, for our caseLayer, and requires a path to the xml file:
After everything is done put the plugin package intosrcdirectory of a certain ROS 2-workspace, build the plugin package (colconbuild--packages-selectnav2_gradient_costmap_plugin--symlink-install) and sourcesetup.bashfile when it necessary.
Now the plugin is ready to use.

## 3- Enable the plugin in Costmap2D
At the next step it is required to tell Costmap2D about new plugin. For that the plugin should be added toplugin_namesandplugin_typeslists innav2_params.yamloptionally forlocal_costmap/global_costmapin order to be enabled in run-time for Controller/Planner Server.plugin_nameslist contains the names of plugin objects. These names could be anything you want.plugin_typescontains types of listed inplugin_namesobjects. These types should correspond tonamefield of plugin class specified in plugin description XML-file.
For example:
YAML-file may also contain the list of parameters (if any) for each plugin, identified by plugins object name.
NOTE: there could be many simultaneously loaded plugin objects of one type. For this,plugin_nameslist should contain different plugins names whether theplugin_typeswill remain the same types. For example:
In this case each plugin object will be handled by its own parameters tree in a YAML-file, like:

## 4- Run GradientLayer plugin
Run Turtlebot3 simulation with enabled Nav2. Detailed instructions how to make it are written atGetting Started. Below is shortcut command for that:
Then goto RViz and click on the “2D Pose Estimate” button at the top and point the location on map as it was described inGetting Started. Robot will be localized on map and the result should be as presented at picture below. There, the gradient costmap can be seen. There are also 2 noticeable things: dynamically updated byGradientLayer::updateCosts()costmap within its bounds and global path curved by gradient:

Code Examples:

Language: unknown
File: nav2_costmap_2d::Layer
```
namespace
nav2_gradient_costmap_plugin
{
class
GradientLayer
:
public
nav2_costmap_2d
::
Layer
```

Language: unknown
File: GradientLayer::onInitialize()
```
declareParameter
(
"enabled"
,
rclcpp
::
ParameterValue
(
true
));
node_
->
get_parameter
(
name_
+
"."
+
"enabled"
,
enabled_
);
```

Language: unknown
File: need_recalculation_
```
need_recalculation_
=
false
;
```

Language: unknown
File: updateWithTrueOverwrite()
```
int
gradient_index
;
for
(
int
j
=
min_j
;
j
<
max_j
;
j
++
)
{
// Reset gradient_index each time when reaching the end of re-calculated window
// by OY axis.
gradient_index
=
0
;
for
(
int
i
=
min_i
;
i
<
max_i
;
i
++
)
{
int
index
=
master_grid
.
getIndex
(
i
,
j
);
// setting the gradient cost
unsigned
char
cost
=
(
LETHAL_OBSTACLE
-
gradient_index
*
GRADIENT_FACTOR
)
%
255
;
if
(
gradient_index
<=
GRADIENT_SIZE
)
{
gradient_index
++
;
}
else
{
gradient_index
=
0
;
}
master_array
[
index
]
=
cost
;
}
}
```

Language: unknown
File: PLUGINLIB_EXPORT_CLASS
```
#include "pluginlib/class_list_macros.hpp"
PLUGINLIB_EXPORT_CLASS(nav2_gradient_costmap_plugin::GradientLayer, nav2_costmap_2d::Layer)

```

Language: unknown
File: description
```
<library
path=
"nav2_gradient_costmap_plugin_core"
>
<class
type=
"nav2_gradient_costmap_plugin::GradientLayer"
base_class_type=
"nav2_costmap_2d::Layer"
>
<description>
This
is
an
example
plugin
which
puts
repeating
costs
gradients
to
costmap
</description>
</class>
</library>
```

Language: unknown
File: share
```
pluginlib_export_plugin_description_file(nav2_costmap_2d gradient_layer.xml)

```

Language: unknown
File: Layer
```
<export>
  <costmap_2d plugin="${prefix}/gradient_layer.xml" />
  ...
</export>

```

Language: unknown
File: plugin:MyPlugin::Plugin
```
--- a/nav2_bringup/bringup/params/nav2_params.yaml
+++ b/nav2_bringup/bringup/params/nav2_params.yaml
@@ -124,8 +124,8 @@ local_costmap:
      width: 3

      height: 3

      resolution: 0.05

-      plugins: ["obstacle_layer", "voxel_layer", "inflation_layer"]
+      plugins: ["obstacle_layer", "voxel_layer", "gradient_layer"]
      robot_radius: 0.22

      inflation_layer:

        cost_scaling_factor: 3.0

@@ -171,8 +171,8 @@ global_costmap:
      robot_base_frame: base_link

      global_frame: map

      use_sim_time: True

-      plugins: ["static_layer", "obstacle_layer", "voxel_layer", "inflation_layer"]
+      plugins: ["static_layer", "obstacle_layer", "voxel_layer", "gradient_layer"]
      robot_radius: 0.22

      resolution: 0.05

      obstacle_layer:

```

Language: unknown
File: plugin_types
```
plugins: ["obstacle_layer", "gradient_layer_1", "gradient_layer_2"]

```

Language: unknown
File: plugin_types
```
gradient_layer_1:
  plugin: nav2_gradient_costmap_plugin::GradientLayer # In Iron and older versions, "/" was used instead of "::"
  enabled: True
  ...
gradient_layer_2:
  plugin: nav2_gradient_costmap_plugin::GradientLayer # In Iron and older versions, "/" was used instead of "::"
  enabled: False
  ...

```

Language: unknown
File: plugin_types
```
$
ros2
launch
nav2_bringup
tb3_simulation_launch.py

```
