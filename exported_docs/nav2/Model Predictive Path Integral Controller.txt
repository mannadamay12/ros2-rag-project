Title: Model Predictive Path Integral Controller
URL: https://docs.nav2.org/configuration/packages/configuring-mppic.html#path-align-critic
Section: getting_started/index.html
--------------------------------------------------------------------------------


## MPPI Parameters


## Trajectory Visualization


## Path Handler


## Ackermann Motion Model


## Constraint Critic
This critic penalizes trajectories that have components outside of the set dynamic or kinematic constraints

## Goal Angle Critic
This critic incentivizes navigating to achieve the angle of the goal posewhen in reasonable proximity to goal

## Goal Critic
This critic incentivizes navigating spatially towards the goal when in reasonable proximity to goal

## Obstacles Critic
This critic incentivizes navigating away from obstacles and critical collisions using either a circular robot point-check or full SE2 footprint check using distances from obstacles.

## Cost Critic
This critic incentivizes navigating away from obstacles and critical collisions using either a circular robot point-check or full SE2 footprint check using the costmap values.

## Path Align Critic
This critic incentivizes aligning with the global path, if relevant. It does not implement path following behavior.

## Path Angle Critic
This critic penalizes trajectories at a high relative angle to the path. This helps the robot make sharp turns when necessary due to large accumulated angular errors.

## Path Follow Critic
This critic incentivizes making progress along the path. This is what drives the robot forward along the path.

## Prefer Forward Critic
This critic incentivizes moving in the forward direction, rather than reversing.

## Twirling Critic
This critic penalizes unnecessary ‘twisting’ with holonomic vehicles. It adds a constraint on the rotation angle to keep it consistent.

## Velocity Deadband Critic
This critic penalizes velocities that fall below the deadband threshold, helping to mitigate hardware limitations on certain platforms.

## Example


## Notes to Users


## General Words of Wisdom
Themodel_dtparameter generally should be set to the duration of your control frequency. So if your control frequency is 20hz, this should be0.05. However, you may also set it lowerbut not larger.
Visualization of the trajectories usingvisualizeuses compute resources to back out trajectories for visualization and therefore slows compute time. It is not suggested that this parameter is set totrueduring a deployed use, but is a useful debug instrument while tuning the system, but use sparingly. Visualizing 2000 batches @ 56 points at 30 hz isa lot.
The most common parameters you might want to start off changing are the velocity profiles (vx_max,vx_min,wz_max, andvy_maxif holonomic) and themotion_modelto correspond to your vehicle. Its wise to consider theprune_distanceof the path plan in proportion to your maximum velocity and prediction horizon. The only deeper parameter that will likely need to be adjusted for your particular settings is the Obstacle critics’repulsion_weightsince the tuning of this is proprtional to your inflation layer’s radius. Higher radii should correspond to reducedrepulsion_weightdue to the penalty formation (e.g.inflation_radius-min_dist_to_obstacle). If this penalty is too high, the robot will slow significantly when entering cost-space from non-cost space or jitter in narrow corridors. It is noteworthy, but likely not necessary to be changed, that the Obstacle critic may use the full footprint information ifconsider_footprint=true, though comes at an increased compute cost.
Otherwise, the parameters have been closely pre-tuned by your friendly neighborhood navigator to give you a decent starting point that hopefully you only need to retune for your specific desired behavior lightly (if at all). Varying costmap parameters or maximum speeds are the actions which require the most attention, as described below:

## Prediction Horizon, Costmap Sizing, and Offsets
As this is a predictive planner, there is some relationship between maximum speed, prediction times, and costmap size that users should keep in mind while tuning for their application. If a controller server costmap is set to 3.0m in size, that means that with the robot in the center, there is 1.5m of information on either side of the robot. When your prediction horizon (time_steps*model_dt) at maximum speed (vx_max) is larger than this, then your robot will be artificially limited in its maximum speeds and behavior by the costmap limitation. For example, if you predict forward 3 seconds (60 steps @ 0.05s per step) at 0.5m/s maximum speed, theminimumrequired costmap radius is 1.5m - or 3m total width.
The same applies to the Path Follow and Align offsets from furthest. In the same example if the furthest point we can consider is already at the edge of the costmap, then further offsets are thresholded because they’re unusable. So its important while selecting these parameters to make sure that the theoretical offsets can exist on the costmap settings selected with the maximum prediction horizon and velocities desired. Setting the threshold for consideration in the path follower + goal critics as the same as your prediction horizon can make sure you have clean hand-offs between them, as the path follower will otherwise attempt to slow slightly once it reaches the final goal pose as its marker.
The Path Follow critic cannot drive velocities greater than the projectable distance of that velocity on the available path on the rolling costmap. The Path Align criticoffset_from_furthestrepresents the number of path points a trajectory passes through while tracking the path. If this is set either absurdly low (e.g. 5) it can trigger when a robot is simply trying to start path tracking causing some suboptimal behaviors and local minima while starting a task. If it is set absurdly high (e.g. 50) relative to the path resolution and costmap size, then the critic may never trigger or only do so when at full-speed. A balance here is wise. A selection of this value to be ~30% of the maximum velocity distance projected is good (e.g. if a planner produces points every 2.5cm, 60 can fit on the 1.5m local costmap radius. If the max speed is 0.5m/s with a 3s prediction time, then 20 points represents 33% of the maximum speed projected over the prediction horizon onto the path). When in doubt,prediction_horizon_s*max_speed/path_resolution/3.0is a good baseline.

## Obstacle, Inflation Layer, and Path Following
There also exists a relationship between the costmap configurations and the Obstacle critic configurations. If the Obstacle critic is not well tuned with the costmap parameters (inflation radius, scale) it can cause the robot to wobble significantly as it attempts to take finitely lower-cost trajectories with a slightly lower cost in exchange for jerky motion. It may also perform awkward maneuvers when in free-space to try to maximize time in a small pocket of 0-cost over a more natural motion which involves moving into some low-costed region. Finally, it may generally refuse to go into costed space at all when starting in a free 0-cost space if the gain is set disproportionately higher than the Path Follow scoring to encourage the robot to move along the path. This is due to the critic cost of staying in free space becoming more attractive than entering even lightly costed space in exchange for progression along the task.
Thus, care should be taken to select weights of the obstacle critic in conjunction with the costmap inflation radius and scale so that a robot does not have such issues. How I (Steve, your friendly neighborhood navigator) tuned this was to first create the appropriate obstacle critic behavior desirable in conjunction with the inflation layer parameters. Its worth noting that the Obstacle critic converts the cost into a distance from obstacles, so the nature of the distribution of costs in the inflation isn’t overly significant. However, the inflation radius and the scale will define the cost at the end of the distribution where free-space meets the lowest cost value within the radius. So testing for quality behavior when going over that threshold should be considered.
As you increase or decrease your weights on the Obstacle, you may notice the aforementioned behaviors (e.g. won’t overcome free to non-free threshold). To overcome them, increase the FollowPath critic cost to increase the desire for the trajectory planner to continue moving towards the goal. Make sure to not overshoot this though, keep them balanced. A desirable outcome is smooth motion roughly in the center of spaces without significant close interactions with obstacles. It shouldn’t be perfectly following a path yet nor should the output velocity be wobbling jaggedly.
Once you have your obstacle avoidance behavior tuned and matched with an appropriate path following penalty, tune the Path Align critic to align with the path. If you design exact-path-alignment behavior, its possible to skip the obstacle critic step as highly tuning the system to follow the path will give it less ability to deviate to avoid obstacles (though it’ll slow and stop). Tuning the critic weight for the Obstacle critic high will do the job to avoid near-collisions but the repulsion weight is largely unnecessary to you. For others wanting more dynamic behavior, itcanbe beneficial to slowly lower the weight on the obstacle critic to give the path alignment critic some more room to work. If your path was generated with a cost-aware planner (like all provided by Nav2) and providing paths sufficiently far from obstacles for your satisfaction, the impact of a slightly reduced Obstacle critic with a Path Alignment critic will do you well. Not over-weighting the path align critic will allow the robot to  deviate from the path to get around dynamic obstacles in the scene or other obstacles not previous considered during path planning. It is subjective as to the best behavior for your application, but it has been shown that MPPI can be an exact path tracker and/or avoid dynamic obstacles very fluidly and everywhere in between. The defaults provided are in the generally right regime for a balanced initial trade-off.

Code Examples:

Language: unknown
File: inflation_radius
```
controller_server
:
ros__parameters
:
controller_frequency
:
30.0
FollowPath
:
plugin
:
"nav2_mppi_controller::MPPIController"
time_steps
:
56
model_dt
:
0.05
batch_size
:
2000
vx_std
:
0.2
vy_std
:
0.2
wz_std
:
0.4
vx_max
:
0.5
vx_min
:
-0.35
vy_max
:
0.5
wz_max
:
1.9
ax_max
:
3.0
ax_min
:
-3.0
ay_max
:
3.0
az_max
:
3.5
iteration_count
:
1
prune_distance
:
1.7
transform_tolerance
:
0.1
temperature
:
0.3
gamma
:
0.015
motion_model
:
"DiffDrive"
visualize
:
false
reset_period
:
1.0
# (only in Humble)
regenerate_noises
:
false
TrajectoryVisualizer
:
trajectory_step
:
5
time_step
:
3
AckermannConstraints
:
min_turning_r
:
0.2
critics
:
[
"ConstraintCritic"
,
"CostCritic"
,
"GoalCritic"
,
"GoalAngleCritic"
,
"PathAlignCritic"
,
"PathFollowCritic"
,
"PathAngleCritic"
,
"PreferForwardCritic"
]
ConstraintCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
4.0
GoalCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
5.0
threshold_to_consider
:
1.4
GoalAngleCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
3.0
threshold_to_consider
:
0.5
PreferForwardCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
5.0
threshold_to_consider
:
0.5
# ObstaclesCritic:
#   enabled: true
#   cost_power: 1
#   repulsion_weight: 1.5
#   critical_weight: 20.0
#   consider_footprint: false
#   collision_cost: 10000.0
#   collision_margin_distance: 0.1
#   near_goal_distance: 0.5
#   inflation_radius: 0.55 # (only in Humble)
#   cost_scaling_factor: 10.0 # (only in Humble)
CostCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
3.81
critical_cost
:
300.0
consider_footprint
:
true
collision_cost
:
1000000.0
near_goal_distance
:
1.0
trajectory_point_step
:
2
PathAlignCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
14.0
max_path_occupancy_ratio
:
0.05
trajectory_point_step
:
4
threshold_to_consider
:
0.5
offset_from_furthest
:
20
use_path_orientations
:
false
PathFollowCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
5.0
offset_from_furthest
:
5
threshold_to_consider
:
1.4
PathAngleCritic
:
enabled
:
true
cost_power
:
1
cost_weight
:
2.0
offset_from_furthest
:
4
threshold_to_consider
:
0.5
max_angle_to_furthest
:
1.0
mode
:
0
# VelocityDeadbandCritic:
#   enabled: true
#   cost_power: 1
#   cost_weight: 35.0
#   deadband_velocities: [0.05, 0.05, 0.05]
# TwirlingCritic:
#   enabled: true
#   twirling_cost_power: 1
#   twirling_cost_weight: 10.0
```
