Title: Filtering of Noise-Induced Obstacles
URL: https://docs.nav2.org/tutorials/docs/filtering_of_noise-induced_obstacles.html#tutorial-steps
Section: getting_started/index.html
--------------------------------------------------------------------------------


## Overview
Noisy sensor measurements can cause to errors inVoxelLayerorObstacleLayer. As a result, salt and pepper noise may appear on the costmap. This noise creates false obstacles that prevent the robot from finding the best path on the map. While the images above show both salt and pepper noise as well as error due to mislocalization, this layer will only remove sensor noise, not mislocalized artifacts misaligned with the static map.
This tutorial shows how to configure filtering of false obstacles caused by noise. This functionality is provided by theDenoiseLayercostmap layer plugin which will be enabled and used in this document.

## Requirements
It is assumed that ROS 2, Gazebo and TurtleBot3 packages are installed or built locally. Please make sure that Nav2 project is also built locally as it was made inBuild and Install.

## Tutorial Steps


## 1. Enable Denoise Layer
Denoise Layer is Costmap2D plugin. You can enable theDenoiseLayerplugin in Costmap2D by addingdenoise_layerto thepluginsparameter innav2_params.yaml. You can place it in theglobal_costmapand (or)local_costmapto filter noise on a global or local map. The DenoiseLayer plugin should have the following parameter defined:
Full list of parameters supported byDenoiseLayerare listed atDenoise Layer Parameterspage.
It is important to note thatDenoiseLayertypically should be placed before the inflation layer.
This is required to prevent inflation from noise-induced obstacles.
Moreover,DenoiseLayerprocesses only obstacle information in the costmap.
ValuesINSCRIBED_INFLATED_OBSTACLE,LETHAL_OBSTACLEand optionallyNO_INFORMATIONwill be interpreted as obstacle cell. Cells with any other values will be interpreted asFREE_SPACEwhen processed (won’t be distorted in the cost map).
If a cell with an obstacle is recognized as noise, it will be replaced byFREE_SPACEafter processing.
To enableDenoiseLayerfor both global and local costmaps, use the following configuration:

## 2. Run Nav2 stack
After Denoise Layer was enabled for global/local costmaps, run Nav2 stack as written inGetting Started:
And check that filter is working properly: with the default parameters,
no standalone obstacles should remain on the cost map. This can be checked, for example, in RViz main window displaying local and global costmaps after removing unnecessary particles (illustrated at the top of this tutorial).

## How it works
The plugin is based on two algorithms.
When parameterminimal_group_size= 2, the first algorithm turns on.
It applyerosionfunction with kernel from image below (left ifgroup_connectivity_type= 4 or right ifgroup_connectivity_type= 8) to the costmap.
White color of the kernel pixel means to use the value, black means to ignore it.
As a result of erosion function the neighbors image is created. Each possible position of the kernel on the costmap corresponds to one pixel of the neighbors image. The pixel value of this image is equal to the maximum of 4/8 costmap pixels corresponding to the white pixels of the mask.
In other words, the pixel of the neighbors image is equal to the obstacle code if there is an obstacle nearby, the free space code in other case.
After that, obstacles corresponding to free space code on neighbors image are removed.
This process is illustrated below. On the left side of the image is a costmap, on the right is a neighbors image. White pixels are free space, black pixels are obstacles,group_connectivity_type= 4.
Obstacles marked at the end of the animation will be removed.
When parameterminimal_group_size> 2, the second algorithm is executed.
This is a generalized solution that allows you to remove groups of adjacent obstacles if their total number is less thanminimal_group_size.
To select groups of adjacent obstacles, the algorithm performs their segmentation.
The type of cell connectivity in one segment is determined by the parametergroup_connectivity_type.
Next, the size of each segment is calculated.
Obstacles segments with size less than theminimal_group_sizeare replaced with empty cells.
This algorithm is about 10 times slower than first, so use it with caution and only when necessary.
Its execution time depends on the size of the processed map fragment (and not depend on the value ofminimal_group_size).
This algorithm is illustrated in the animation below (group_connectivity_type= 8).
Obstacles marked at the end of the animation will be removed (groups that size less 3).

Code Examples:

Language: unknown
File: DenoiseLayer
```
global_costmap:
  global_costmap:
    ros__parameters:
      ...
      plugins: ["static_layer", "obstacle_layer", "denoise_layer", "inflation_layer"]
      ...
      denoise_layer:
        plugin: "nav2_costmap_2d::DenoiseLayer"
        enabled: True
...
local_costmap:
  local_costmap:
    ros__parameters:
      ...
      plugins: ["voxel_layer", "denoise_layer", inflation_layer"]
      ...
      keepout_filter:
        plugin: "nav2_costmap_2d::DenoiseLayer"
        enabled: True

```

Language: unknown
File: DenoiseLayer
```
ros2
launch
nav2_bringup
tb3_simulation_launch.py
headless:
=
False

```
