Title: Galactic to Humble
URL: https://docs.nav2.org/migration/Galactic.html
Section: getting_started/index.html
--------------------------------------------------------------------------------


## Major improvements to Smac Planners
The Smac Planner was significantly improved, of both the 2D and Hybrid-A* implementations, making the paths better, faster, and of higher quality.
Additional improvements were made to include aanalytic_expansion_max_lengthparameter such that analytic expansions are limited in their potential length. If the length is too far, reject this expansion. This prevents unsafe shortcutting of paths into higher cost areas far out from the goal itself, let search to the work of getting close before the analytic expansion brings it home. This should never be smaller than 4-5x the minimum turning radius being used, or planning times will begin to spike.
Further, the traversal cost and heuristic cost computations were updatedrequiring retuning of your penalty functionsif you have a previously existing configuration. Defaults of the algorithm were also retuned appropriately to the change for similar our of the box behavior as before (to use as a reference).

## Simple (Python) Commander
This PR 2411introduces a new package to Nav2, called thenav2_simple_commander. It is a set of functions in an object,BasicNavigator, which can be used to build Nav2-powered autonomy tasks in Python3 without concerning yourself with the Nav2, ROS 2, or Action server details. It contains a simple API taking common types (primarilyPoseStamped) and handles all of the implementation details behind the hood. For example, this is a simple navigation task using this API:
The full API can be found in the README of the package. A number of well commented examples and demos can also be found in the package’s source code at the link prior.

## Reduce Nodes and Executors
In order for nav2 to make the best use of ROS 2, we need minimize the number of nodes and executors in nav2, which can improve performance.
This functionality has been discussed inthe ticket #816, and carried out in

## API Change for nav2_core
PR 2976changes the API fornav2_core::Controllerandnav2_core::Smootherby replacing the use of shared pointer references(constshared_ptr<>&)to shared pointers(shared_ptr<>).
Use of shared pointer references meant that the shared pointer counter was never incremented.

## Extending the BtServiceNode to process Service-Results
This PR 2481andPR 2992addressthe ticketandthis ticketand adds a virtualon_completion()function to theBtServiceNodeclass (can be found here).
Similar to the already existing virtualon_wait_for_result()function, it can be overwritten in the child class to react to a respective event with some user-defined operation.
The addedon_completion()function will be called after the service interaction of theBtServiceNodehas been successfully completed.
The returnedBT::NodeStatuswill set the current status of the BT-Node. Since the function has access to the results of the service, the returned node-status can depend on those service results, for example.
The normal behavior of theBtServiceNodeis not affected by introducing theon_completion()function, since the the default implementation still simply returnsBT::NodeStatus::SUCCESS, if the service interaction completed successfully.

## Including new Rotation Shim Controller Plugin
This PR 2718introduces the newnav2_rotation_shim_controller. This controller will check the rough heading difference with respect to the robot and a newly received path. If within a threshold, it will pass the request onto the primary controller to execute. If it is outside of the threshold, this controller will rotate the robot towards that path heading. Once it is within the tolerance, it will then pass off control-execution from this rotation shim controller onto the primary controller plugin. At this point, the robot is still going to be rotating, allowing the current plugin to take control for a smooth hand off into path tracking.
The Rotation Shim Controller is suitable for:

## Spawning the robot in Gazebo
This PR 2473deletes the pkgnav2_gazebo_spawnerinside nav2_bringup directory. Instead ofnav2_gazebo_spawnerthe Nodespawn_entity.pyofgazebo_rosis recommended to spawn the robot in gazebo.
Note that

## Recovery Behavior Timeout
Recoveries in Nav2, spin and backup, now havetime_allowanceports in their BT nodes and request fields in their actions to specify a timeout. This helps ensure that the robot can exit a backup or spin primitive behavior in case it gets stuck or otherwise is unable to backup the full distance over a reasonable block of time.

## New parameteruse_final_approach_orientationfor the 3 2D planners
Pull request 2488adds a new parameteruse_final_approach_orientationto the 3 2D planners (Theta*, SmacPlanner2D and NavFn),falseby default. Iftrue, the last pose of the path generated by the planner will have its orientation set to the approach orientation, i.e. the orientation of the vector connecting the last two points of the path. It allows sending the robot to a position (x,y) instead of a pose (x,y,theta) by effectively ignoring the goal orientation.
For example, below, for the same goal with an orientaton pointed left of the screen,use_final_approach_orientation=false(left) anduse_final_approach_orientation=true(right)

## SmacPlanner2D and Theta*: fix goal orientation being ignored
This pull request 2488fixesthe  issueof the goal pose orientation being ignored (the end path pose orientation was always set to 0).

## SmacPlanner2D, NavFn and Theta*: fix small path corner cases
This PR 2488ensures the planners are not failing when the distance between the start and the goal is small (i.e. when they are on the same costmap cell), and in that case the output path is constructed with a single pose.

## Change and fix behavior of dynamic parameter change detection
Thisandthis PRmodify the method used to catch the changes of dynamic parameters. The motivation was to fix the issue thatvoidon_parameter_event_callback(constrcl_interfaces::msg::ParameterEvent::SharedPtrevent)was called for every parameter change of every node leading to unwanted parameter changes if 2 different nodes had the same parameter name.

## Dynamic Parameters
Newly added dynamic parameters to:

## BT Action Nodes Exception Changes
When BT action nodes throw exceptions due to networking or action server failures, they now return a status code ofFAILUREto fail that particular action in the behavior tree to react to. This is in contrast to prior where the exceptions thrown from networking were sent to the root tree which would count as a task-level failure that the tree could not react to.

## BT Navigator Groot Multiple Navigators
This PR 2627creates separate parameters for groot monitoring for the NavToPose and NavThroughPoses navigator types so you can individually track the state of each behavior tree through the ZMQ publisher. This resolves a long-standing problem after we added multiple navigator types to BT Navigator that you could only view the nav to poses BT execution live. BT.CPP and Groot only support one static ZMQ stream at a time, so there is a bit of a quirk where you must locally reset Groot after switching trees in order to view the live stream of the Nav Through Poses BT, if in use. This is a state of the BT.CPP and Groot libraries and not something we can resolve within Nav2.
There is some thought into the future regarding complete deprecation of live BT monitoring using Groot due to this quirk and the almost-certain infux of tickets on the topic. Groot will however always be supported for visualizing behavior tree XML files and modifications, simply not visualizing the BT execution live during robot navigation.

## Removed Kinematic Limiting in RPP
The parametersmax_linear_accelandmax_linear_decelwere removed along with the kinematic limiting in the controller causing instabilities. Instead, use a velocity smoother available in the ROS ecosystem if you would like similar behavior.

## Added Smoother Task Server
A new task server was added which loads smoother plugins and executes them to improve quality of an existing planned path. Smoothing action can be called from a behavior tree using SmoothPath action node.PR 2569implements andPR 2875adds in the first of the plugins using it with a simple smoother. Other smoothers are in development and will be added in the future.

## Removed Use Approach Velocity Scaling Param in RPP
The parameteruse_approach_linear_velocity_scalingis removed in favor of always on to help in smooth transitions to the goal.This PR 2701implements.

## Refactored AMCL motion models as plugins
This PR 2642creates plugins for the different motion models currently used in AMCL. This functionality enables users to use any custom motion model by creating it as a plugin and changing the robot_model_type parameter to the name of the plugin in nav2_params.yaml file. This helps to use custom motion models without the need to modify the AMCL source code.

## Dropping Support for Live Groot Monitoring of Nav2
It was a great feature idea but never quite panned out, especially after we introduced multiple navigator types in the BT Navigator server. The issue we run into primarily is that Zero-MQ prevents users from producing multiple logger types in the same process. Since BT nav has multiple servers, the swapping between them for viewing has never had a clean hand off causing folks to file tickets or have nasty logs appear or ZMQ crashes in the background. The BT.CPP client for this doesn’t allow us to have a clean shutdown process so we’re left with hoping that ZMQ properly handles the situation, which it rarely does. Further, Groot only supports visualizing one type of tree at a time so for applications often switching between navigator types, its not possible to use a single groot client, causing great frustration.
So, what I propose here is to remove live monitoring of the BT from Nav2.We can still use Groot to modify, visualize, and generally work with behavior trees, the only thing being removed is to live view the executing behavior tree as Nav2 is currently executing it (it used to light up the boxes of the current nodes). This was of dubious value anyhow, since the tree ticks so fast its difficult to visualize and get meaningful insights into things as the system is moving so quickly.

## Replanning Only if Path is Invalid
This PR 2591creates two new condition BT node to facilitate replanning only if path becomes invalid rather than constantly replanning. These new nodes were integrated into the default BT.

## Fix CostmapLayer clearArea invert param logic
This PR 2772fixes the invert paramlogic of the CostmapLayer clearArea function. Hence correcting the behavior of the clearAroundRobot and clearExceptRegion services and their corresponding BT actions.

## Dynamic Composition
This PR 2750provides a optional bringup based on ROS2 dynamic composition for users. It can be used to compose all Nav2 nodes in a single process instead of launching these nodes separately, which is useful for embedded systems users that need to make optimizations due to harsh resource constraints. it’s used by default, but can be disabled by using the launch argumentuse_composition:=False.
Some experiments to show performance improvement of dynamic composition, and the cpu and memory are captured bypsutil:
The way of dynamic composition consumes lower memory(saves ~70%),  and lower cpu (saves ~13%) than normal multiple processes.

## BT Cancel Node
This PR 2787caters the users with an abstract node to develop cancel behaviors for different servers present in the Nav2 stack such as the controller_server, recovery_server and so on. As a start, this PR also provides theCancelControlbehavior to cancel the goal given to the controller_server. As an addition to theCancelControlThis PR 2856provides the users with the option to cancel the recoveries such as thebackup,spinandwait.

## BT PathLongerOnApproach Node
In thePR, a new Decorator BT node known asPathLongerOnApproachhas been added to provide with the functionality to check and potentially handle longer path generated due to an obstacle in the given goal proximity. To demonstrate this functionality, a new BTnavigate_to_pose_w_replanning_goal_patience_and_recovery.xmlwould serve both as an example and ready-to-use BT for a specific application that wishes to optimize their process cycle time. Demo of the developed BT can be seen below, where the robot pauses when close to a goal to see if the dynamic obstacle moves out of the way. Else, it executes the replan:
Obstacle does not clear at all, withobstacle_clearance_timeto be 3 seconds:
Obstacle clears and you can see the robot pass through the (could have been ideally the) same path:

## BT TruncatePathLocal Node
In thePR 2753, a new Action BT node namedTruncatePathLocalhas been added to extract a bounded-length path section near robot to be used e.g. for collision checking or computationally expensive smoothers

## Constrained Smoother
Inthe PR 2753, a new Smoother namednav2_constrained_smoother::ConstrainedSmootherhas been added to optimize various path criteria such as smoothness or distance from obstacles, maintaining minimum turning radius

## Replanning at a Constant Rate and if the Path is Invalid
This PR 2804introduces a new behavior tree that navigates to pose with consistent replanning and if the path becomes invalid.
To facilitate the new behavior tree a new condition node PathExpiringTimer was introduced to trigger replanning at a consistent rate.

## Euclidean Distance 2D
This PR 2865changes Euclidean distance calculation throughout nav2 to project on to the XY plane (i.e. discard any information related to components in Z).
This may potentially subtly change the way certain BT nodes, BT Navigators, controller servers, planner servers, and RPP behave if using custom plugins outside the Nav2 ecosystem.

## Recovery To Behavior
This PR 2867renames the nav2_recoveries to nav2_behaviors.
In navigation_launch.py recoveries_server -> behavior_server and nav2_recoveries -> nav2_behaviors.
In nav2_params.yaml recovery_plugins -> behavior_plugins and nav2_recoveries -> nav2_behaviors.

## Respawn Support in Launch and Lifecycle Manager
PR 2752enables respawn support in Nav2. In the launch files, you may setuse_respawntotrueto enable respawning of servers that crash. This is only available in non-composed systems, since in composed systems, all of the nodes are under a single process and a crash anywhere will bring everything down (including the lifecycle manager itself). Even if the container was set to respawn, it would only respawn the empty container, not with all of the components loaded into it.
That PR also enables the lifecycle manager to check if a system goes down due to a crash. If so, it allows the manager to check if the server comes back online within a given timeout period. If it does, it will automatically retransition the system back up to active to continue on its task automatically.

## New Nav2 Velocity Smoother
PR 2964introduces thenav2_velocity_smootherfor smoothing velocity commands from Nav2 to a robot controller by velocity, acceleration, and deadband constraints. SeeVelocity Smootherfor more details. It is not included in the default bringup batteries included fromnav2_bringup.

## Goal Checker API Changed
PR 2965adds an extra argument in the initialize function of thenav2_core::GoalCheckerclass.
The extra argument is a costmap_ros pointer. This is used to check if the goal is in collision, so that we can avoid moving towards the goal and replanning can be initiates using some BT plugin.

## Added Assisted Teleop
PR 2904adds a new behavior for assisted teleop along with two new BT nodes AssistedTeleop and CancelAssistedTeleop.

Code Examples:

Language: unknown
File: PoseStamped
```
def
main
():
rclpy
.
init
()
navigator
=
BasicNavigator
()
# Set our demo's initial pose
initial_pose
=
PoseStamped
()
...
populate
pose
...
navigator
.
setInitialPose
(
initial_pose
)
# Wait for navigation to fully activate
navigator
.
waitUntilNav2Active
()
# Go to our demos first goal pose
goal_pose
=
PoseStamped
()
...
populate
pose
...
navigator
.
goToPose
(
goal_pose
)
while
not
navigator
.
isTaskComplete
():
feedback
=
navigator
.
getFeedback
()
...
do
something
with
feedback
...
# Basic navigation timeout
if
Duration
.
from_msg
(
feedback
.
navigation_time
)
>
Duration
(
seconds
=
600.0
):
navigator
.
cancelNav
()
result
=
navigator
.
getResult
()
if
result
==
TaskResult
.
SUCCEEDED
:
print
(
'Goal succeeded!'
)
elif
result
==
TaskResult
.
CANCELED
:
print
(
'Goal was canceled!'
)
elif
result
==
TaskResult
.
FAILED
:
print
(
'Goal failed!'
)
```

Language: unknown
File: BtServiceNode
```
/**
* @brief Function to perform some user-defined operation upon successful
* completion of the service. Could put a value on the blackboard.
* @param response can be used to get the result of the service call in the BT Node.
* @return BT::NodeStatus Returns SUCCESS by default, user may override to return another value
*/
virtual
BT
::
NodeStatus
on_completion
(
std
::
shared_ptr
<
typename
ServiceT
::
Response
>
/*response*/
)
{
return
BT
::
NodeStatus
::
SUCCESS
;
}
```
