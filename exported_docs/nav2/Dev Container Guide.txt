Title: Dev Container Guide
URL: https://docs.nav2.org/development_guides/devcontainer_docs/devcontainer_guide.html#creating-dev-containers
Section: getting_started/index.html
--------------------------------------------------------------------------------


## Creating Dev Containers
Before creating a dev container, you’ll want to choose the exact configuration to use. By default the.devcontainer/devcontainer.jsonconfiguration is selected, however you can also choose any otherdevcontainer.jsonfile in the.devcontainer/directory, where such configurations can be nested to provide greater customization: either by targeting different stages within different Dockerfiles, overriding any merged metadata or default properties, or inclusion of additional extensions and alternate commands.

## Building the image
When first creating Dev Containers, any supporting tool or service used will download and build the docker images needed to run the container. This includes pulling any parent images the project’s Dockerfile buildsFROM, as well as any tags or layers declared viacacheFrom, as specified in the chosendevcontainer.jsonconfig file. This can take a while, but only needs to be done once, or at least not again until such layers are updated and pushed to the image registry.
Specifically, for this project, the defaultdevcontainer.jsonfile targets thedeverstage within the project’s root Dockerfile, the stage that also includes handy tools for developing the project, such as bash auto completion. This stage is in turn builtFROMthebuilderstage, the stage that only includes the dependencies needed for building the project, as reused by the project’s CI. For example, thedeverstage modifies/etc/bash.bashrcto automatically sourceinstall/setup.bashfrom the underlay workspace, ensuring all VS Code extensions are loaded with the correct environment, while avoiding any race conditions during installation and startup.
To speed up the initial build, images layers from thisbuilderstage are cached by pulling the same image tag used by the project’s CI, hosted from the image registry. This ensures your local dev container replicates our CI environment as close as possible, while benefiting from any cached work preemptively performed by the CI. Yet, this still allows you to customize the project’s Dockerfile and rebuild the container, without needing to update CI images to reflect your local modifications.
Once the base image from the target stage is built, the supporting tool or service may then add additional layers to the image, such as installing additionalfeaturesor customizations. For VS Code, this also includes some fancy file caching for any extensions to install later. Once this custom image is built, it is then used to start the dev container.

## Starting the container
When first creating Dev Containers, any supporting tool or service will invoke a sequence of commands specified in the chosendevcontainer.jsonconfig file. This can take a while, but only needs to be done once, or at least not again until the container is rebuilt, triggered by either updating the Dockerfile, base image, or.devcontainer/config.
Specifically, for this project, the defaultdevcontainer.jsonconfig executes theonCreateCommandto initially colcon cache, clean, and build the overlay workspace for the project. This ensures the workspace is precompiled and ready to use, while also ensuring any changes to the project’s source code are reflected in the container. This is useful for:
While the colcon workspace is being built, VS Code will simultaneously install any specified extensions and settings. Next theupdateContentCommandis executed, which reruns whenever the container is started or restarted. Specifically, for this project, this command re-cleans and re-builds the same colcon workspace as before, but only for invalidated packages detected by colcon cache using the lockfiles initialized during theonCreateCommand. This caching behavior also replicates the project’s CI workflow. This is useful for:
Finally, thepostCreateCommandis executed, which also reruns whenever the container is started or restarted. Specifically, for this project, this command makes a last few tweaks to the user’s environment to improve the development experience.
To speed up subsequent startups, volumes that are mounted to the container store a persistent ccache and colcon workspace, while the environment is set to enableccacheviacolcon mixins. These volumes are labeled using thedevcontainerIdvariable, which uniquely identify the dev container on a Docker host, allowing us to refer to a common identifier that is unique to the dev container, while remaining stable across rebuilds. This is useful for:
Additionally, the container can be grantedprivilegedand non-defaultLinux capabilities, connected using thehostnetwork mode andIPCandPIDspaces, with a relaxedsecurity configurationand seccomp confinement for native debugging and external connectivity. This is useful for:

## Using Dev Containers
Once the dev container has been created and setup completed, VS Code will open a new workspace directly from the project’s root directory, which itself is mounted within the source directory in the overlay colcon workspace. From here you can build, test, and debug the project as you normally would, with the added benefit of having the project’s dependencies, intellisense, linters, and other extensions pre-configured and ready to use. Simply open a new terminal (Crtl+Shift+`), cd to the root of the colcon workspace, and run the usual colcon commands.

## Terminals
If you prefer using an alternate terminal emulator, rather than the built-in VS Code terminal, you can open a separate shell session by simply using the Dev Container CLI or directly using the Docker CLI via theexecsubcommands.

## Lifecycle
While using the dev container, try and keep in mind the lifecycle of the container itself. Specifically, containers are ephemeral, meaning they are normally destroyed and recreated whenever the dev environment is rebuilt or updated. Subsequently, a best practice is to avoid storing any persistent data within the container, and instead utilize the project’s source directory, or a separate mounted volume. When altering the development environment inside the container, try to remember to codify your changes into the Dockerfile, or thedevcontainer.jsonconfig file, so that they can be easily reproduced and shared with others.

## Rebuilding
From time to time, you may need to rebuild the dev container, either because the base image, or.devcontainer/config was updated, or simply out of wanting a new fresh development environment. To do so, simply open the Command Palette (Ctrl+Shift+P) and select theRemote-Containers:RebuildContainercommand.
For example, you may need to rebuild the dev container when:
When necessary, you can also rebuild the container from scratch, e.i. without caching from docker, by selecting theRemote-Containers:RebuildContainerWithoutCachecommand. This instead omits the--cache-fromflag from thedockerbuildxcommand, while also adding the--no-cacheand--pullflags to prevent caching from any existing image layers, using only the latest images from a container registry.
Rebuilding without caching may be necessary when:
Specifically, for this project, volumes remain unaffected by this rebuilding process: i.e. those used to mount the ccache directory or colcon workspace. While volume management is left to the user’s discretion, other projects may of course handle this differently, so be sure to check the./devcontainerconfiguration to inspect how various container resources may be managed.

Code Examples:

Language: unknown
File: loginInteractiveShell
```
find
/tmp
-type
f
-path
"*/devcontainers-*/env-loginInteractiveShell.json"
-exec
\
jq
-r
'to_entries | .[] | "\(.key)=\(.value | @sh)"'
{}
\;
>
.env

source
.env

```
