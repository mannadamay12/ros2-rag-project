Title: Setting Up Navigation Plugins
URL: https://docs.nav2.org/setup_guides/algorithm/select_algorithm.html#select-algorithm
Section: tuning/index.html
--------------------------------------------------------------------------------


## Planner and Controller Servers
Navigation algorithms are implemented in Nav2 through the use of plugins running on ROS action servers - the planner, controller and behavior servers (among others). For this section, we discuss the planner and controller servers, which are the heart of the navigation stack. These servers may implement one or more algorithm plugins each with its own configuration tailored for a specific action or robot state. This guide will highlight the different algorithms based on the type of robot and environment the robot is deployed in. This guide will not cover behaviors, smoothers, etc as those are dependent on application and not hardware/environment to offer generalized advice.
The planner server is responsible for implementing algorithms that compute the robot’s path. For example, one plugin can be configured to compute a simple shortest path between two relatively near locations while another plugin computes for a path to locations that cover the entire robot environment.
The controller server generates the appropriate control efforts needed for a robot to complete a task in its local environment. These tasks include but are not limited to: following a path generated by the planner server, avoiding dynamic obstacles along this path, and even charging at a docking station.
As mentioned before, the planner and controller servers host a map of one or multiple plugins wherein a certain plugin will be used for a certain environment, scenario, or task. For instance, the controller server can have a plugin for following a path when in long corridors to stay in the middle of the aisle, and then another plugin for avoiding dynamic obstacles in a crowded place. Selecting which planning algorithm to execute based on the robot’s task can be done through the behavior tree of your navigation system or application server.

## Selecting the Algorithm Plugins
In this section, we discuss some of the available algorithm plugins for the planner and controller servers. We also discuss the purpose of each algorithm, and for which type of robot they are recommended to be used. Lastly, we show some sample yaml configuration that specifies the plugin to be used for each server.

## Planner Server
The algorithm plugins for the planner server find the robot’s path using a representation of its environment captured by its different sensors. Some of these algorithms operate by searching through the environment’s grid space while others expand the robot’s possible states while accounting for path feasibility.
As mentioned, the planner server may utilize plugins that work on the grid space such as theNavFnPlanner,SmacPlanner2D, andThetaStarPlanner. TheNavFn planneris a navigation function planner that uses either Dijkstra or A*.  Next, theSmac 2D plannerimplements a 2D A* algorithm using 4 or 8 connected neighborhoods with a smoother and multi-resolution query. Lastly, theTheta Star planneris an implementation of Theta* using either line of sight to create non-discretely oriented path segments.
One issue you may encounter when using algorithms that work on the grid space is that there is no guarantee that a drivable path can be generated for any type of robot. For example, it is not guaranteed that theNavFnPlannercan plan a feasible path for a non-circular robot in a tight space since it uses the circular footprint of a robot (by approximating the robot’s largest cross-sectional radius) and checks for collisions per costmap grid cell. In addition, these algorithms are also not suitable for ackermann and legged robots since they have turning constraints. That being said, these plugins are best used on robots that can drive in any direction or rotate safely in place, such ascircular differential and circular omnidirectionalrobots.
Another planner plugin is theSmac Hybrid-A* plannerthat supportsarbitrary shaped ackermann and leggedrobots. It is a highly optimized and fully reconfigurable Hybrid-A* implementation supporting Dubin and Reeds-Shepp motion models. This algorithm expands the robot’s candidate paths while considering the robot’s minimum turning radius constraint and the robot’s full footprint for collision avoidance. Thus, this plugin is suitable for arbitrary shaped robots that require full footprint collision checking. It may also be used for high-speed robots that must be navigated carefully to not flip over, skid, or dump load at high speeds.
There is also theSmacLatticeplannerplugin which is based on a State Lattice planner. This plugin functions by expanding the robot state space while ensuring the path complies with the robot’s kinematic constraints. The algorithm provides minimum control sets which allows it to supportdifferential, omnidirectional, and ackermannvehicles of any shape and size with minimal reconfiguration.

## Summary


## Example Configuration
An example configuration of the planner server is shown above. Theplanner_pluginsparameter accepts a list of mapped planner plugin names. For each plugin namespace defined inplanner_plugins(GridBasedin our example), we specify the type of plugin to be loaded in thepluginparameter. Additional configurations must then be specified in this namespace based on the algorithm to be used. Please see theConfiguration Guidefor more details.

## Controller Server
The default controller plugin is theDWB controller. It implements a modified Dynamic Window Approach (DWA) algorithm with configurable plugins to compute the control commands for the robot. This controller makes use of aTrajectoryGeneratorpluginthat generates the set of possible trajectories. These are then evaluated by one or moreCriticplugins, each of which may give a different score based on how they are configured. The sum of the scores from theseCriticpluginsdetermine the overall score of a trajectory. The best scoring trajectory then determines the output command velocity.
TheDWBcontrollercan be used oncircular or non-circular differential, and circular or non-circular omnidirectionalrobots. It may also be configured forackerman and leggedrobots if it is given aTrajectoryGenerationpluginthat produces a set of possible trajectories that considers the robot’s minimum curvature constraint.
Next example of a controller server plugin is theTEB controllerwhich is an MPC time optimal controller. It implements the Timed Elastic Band (TEB) approach which optimizes the robot’s trajectory based on its execution time, distance from obstacles, and feasibility with respect to the robot’s kinematic constraints. This controller can be used ondifferential, omnidirectional, ackermann, and leggedrobots.
Another example for this section is theRegulated Pure Pursuit controller (RPP). This controller implements a variant of the pure pursuit algorithm with added regulation heuristic functions to manage collision and velocity constraints. This variation is implemented to target the needs of service or industrial robots and is suitable for use withdifferential, ackermann, and leggedrobots.
The last example is theVector Pursuit Controller. It implements theVector Pursuit algorithmand calculates the command velocity using screw theory. This controller is suitable for high speed path tracking and sharp turns or when computation resources are limited. It can be used fordifferential, ackermann, and leggedrobots.

## Summary
All of these algorithms work for both circular and non-circular robots.

## Example Configuration
Shown above is a sample basic configuration of the controller server. The list of mapped names for controller plugins are defined in thecontroller_pluginsparameter. Similar to the planner server, each namespace defined in thecontroller_plugins(FollowPathin our example) must define the type of plugin it will use in thepluginparameter. Additional configurations must also be made for the selected algorithm in the namespace. Please see theConfiguration Guidefor more details.

## Conclusion
In this tutorial, we have discussed the roles and configuration of Nav2’s planner and controller servers. To summarize, these servers host a map of one or more algorithm plugins which are selected depending on your robot’s structure and surroundings. We also described a few of the available plugins for the planner and controller servers to help you identify which plugins are suitable for your robot. Lastly, we also provided some simple configuration examples to show how these plugins are instantiated on the servers. You can refer to the configuration guide of the algorithm plugin you will select for more details on its configuration parameters.

Code Examples:

Language: unknown
File: SmacLatticeplanner
```
planner_server
:
ros__parameters
:
planner_plugins
:
[
'GridBased'
]
GridBased
:
plugin
:
'nav2_navfn_planner::NavfnPlanner'
# In Iron and older versions, "/" was used instead of "::"
```

Language: unknown
File: TrajectoryGenerationplugin
```
controller_server
:
ros__parameters
:
controller_plugins
:
[
"FollowPath"
]
FollowPath
:
plugin
:
"dwb_core::DWBLocalPlanner"
```
