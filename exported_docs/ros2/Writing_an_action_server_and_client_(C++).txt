Title: Writing an action server and client (C++)
URL: https://docs.ros.org/en/jazzy/Tutorials/Intermediate/Writing-an-Action-Server-Client/Cpp.html
Section: Installation
--------------------------------------------------------------------------------

Writing an action server and client (C++)Goal:Implement an action server and client in C++.Tutorial level:IntermediateTime:15 minutesContentsBackgroundPrerequisitesTasks1 Creating the custom_action_cpp package2 Writing an action server3 Writing an action clientSummaryRelated contentBackgroundActions are a form of asynchronous communication in ROS.Action clientssend goal requests toaction servers.Action serverssend goal feedback and results toaction clients.PrerequisitesYou will need thecustom_action_interfacespackage and theFibonacci.actioninterface defined in the previous tutorial,Creating an action.Tasks1 Creating the custom_action_cpp packageAs we saw in theCreating a packagetutorial, we need to create a new package to hold our C++ and supporting code.1.1 Creating the custom_action_cpp packageGo into the action workspace you created in theprevious tutorial(remember to source the workspace), and create a new package for the C++ action server:LinuxmacOSWindowscd~/ros2_ws/src
ros2pkgcreate--dependenciescustom_action_interfacesrclcpprclcpp_actionrclcpp_components--licenseApache-2.0--custom_action_cppcd~/ros2_ws/src
ros2pkgcreate--dependenciescustom_action_interfacesrclcpprclcpp_actionrclcpp_components--licenseApache-2.0--custom_action_cppcd\ros2_ws\src
ros2pkgcreate--dependenciescustom_action_interfacesrclcpprclcpp_actionrclcpp_components--licenseApache-2.0--custom_action_cpp1.2 Adding in visibility controlIn order to make the package compile and work on Windows, we need to add in some “visibility control”.
For more details, seeWindows Symbol Visibility in the Windows Tips and Tricks document.Open upcustom_action_cpp/include/custom_action_cpp/visibility_control.h, and put the following code in:#ifndef CUSTOM_ACTION_CPP__VISIBILITY_CONTROL_H_#define CUSTOM_ACTION_CPP__VISIBILITY_CONTROL_H_#ifdef __cplusplusextern"C"{#endif// This logic was borrowed (then namespaced) from the examples on the gcc wiki://     https://gcc.gnu.org/wiki/Visibility#if defined _WIN32 || defined __CYGWIN__#ifdef __GNUC__#define CUSTOM_ACTION_CPP_EXPORT __attribute__ ((dllexport))#define CUSTOM_ACTION_CPP_IMPORT __attribute__ ((dllimport))#else#define CUSTOM_ACTION_CPP_EXPORT __declspec(dllexport)#define CUSTOM_ACTION_CPP_IMPORT __declspec(dllimport)#endif#ifdef CUSTOM_ACTION_CPP_BUILDING_DLL#define CUSTOM_ACTION_CPP_PUBLIC CUSTOM_ACTION_CPP_EXPORT#else#define CUSTOM_ACTION_CPP_PUBLIC CUSTOM_ACTION_CPP_IMPORT#endif#define CUSTOM_ACTION_CPP_PUBLIC_TYPE CUSTOM_ACTION_CPP_PUBLIC#define CUSTOM_ACTION_CPP_LOCAL#else#define CUSTOM_ACTION_CPP_EXPORT __attribute__ ((visibility("default")))#define CUSTOM_ACTION_CPP_IMPORT#if __GNUC__ >= 4#define CUSTOM_ACTION_CPP_PUBLIC __attribute__ ((visibility("default")))#define CUSTOM_ACTION_CPP_LOCAL  __attribute__ ((visibility("hidden")))#else#define CUSTOM_ACTION_CPP_PUBLIC#define CUSTOM_ACTION_CPP_LOCAL#endif#define CUSTOM_ACTION_CPP_PUBLIC_TYPE#endif#ifdef __cplusplus}#endif#endif// CUSTOM_ACTION_CPP__VISIBILITY_CONTROL_H_2 Writing an action serverLet’s focus on writing an action server that computes the Fibonacci sequence using the action we created in theCreating an actiontutorial.2.1 Writing the action server codeOpen upcustom_action_cpp/src/fibonacci_action_server.cpp, and put the following code in:#include<functional>#include<memory>#include<thread>#include"custom_action_interfaces/action/fibonacci.hpp"#include"rclcpp/rclcpp.hpp"#include"rclcpp_action/rclcpp_action.hpp"#include"rclcpp_components/register_node_macro.hpp"#include"custom_action_cpp/visibility_control.h"namespacecustom_action_cpp{classFibonacciActionServer:publicrclcpp::Node{public:usingFibonacci=custom_action_interfaces::action::Fibonacci;usingGoalHandleFibonacci=rclcpp_action::ServerGoalHandle<Fibonacci>;CUSTOM_ACTION_CPP_PUBLICexplicitFibonacciActionServer(constrclcpp::NodeOptions&options=rclcpp::NodeOptions()):Node("fibonacci_action_server",options){usingnamespacestd::placeholders;autohandle_goal=[this](constrclcpp_action::GoalUUID&uuid,std::shared_ptr<constFibonacci::Goal>goal){RCLCPP_INFO(this->get_logger(),"Received goal request with order %d",goal->order);(void)uuid;returnrclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;};autohandle_cancel=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Received request to cancel goal");(void)goal_handle;returnrclcpp_action::CancelResponse::ACCEPT;};autohandle_accepted=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){// this needs to return quickly to avoid blocking the executor,// so we declare a lambda function to be called inside a new threadautoexecute_in_thread=[this,goal_handle](){returnthis->execute(goal_handle);};std::thread{execute_in_thread}.detach();};this->action_server_=rclcpp_action::create_server<Fibonacci>(this,"fibonacci",handle_goal,handle_cancel,handle_accepted);}private:rclcpp_action::Server<Fibonacci>::SharedPtraction_server_;voidexecute(conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Executing goal");rclcpp::Rateloop_rate(1);constautogoal=goal_handle->get_goal();autofeedback=std::make_shared<Fibonacci::Feedback>();auto&sequence=feedback->partial_sequence;sequence.push_back(0);sequence.push_back(1);autoresult=std::make_shared<Fibonacci::Result>();for(inti=1;(i<goal->order)&&rclcpp::ok();++i){// Check if there is a cancel requestif(goal_handle->is_canceling()){result->sequence=sequence;goal_handle->canceled(result);RCLCPP_INFO(this->get_logger(),"Goal canceled");return;}// Update sequencesequence.push_back(sequence[i]+sequence[i-1]);// Publish feedbackgoal_handle->publish_feedback(feedback);RCLCPP_INFO(this->get_logger(),"Publish feedback");loop_rate.sleep();}// Check if goal is doneif(rclcpp::ok()){result->sequence=sequence;goal_handle->succeed(result);RCLCPP_INFO(this->get_logger(),"Goal succeeded");}};};// class FibonacciActionServer}// namespace custom_action_cppRCLCPP_COMPONENTS_REGISTER_NODE(custom_action_cpp::FibonacciActionServer)The first few lines include all of the headers we need to compile.Next we create a class that is a derived class ofrclcpp::Node:classFibonacciActionServer:publicrclcpp::NodeThe constructor for theFibonacciActionServerclass initializes the node name asfibonacci_action_server:explicitFibonacciActionServer(constrclcpp::NodeOptions&options=rclcpp::NodeOptions()):Node("fibonacci_action_server",options)The constructor also instantiates a new action server:loop_rate.sleep();}// Check if goal is doneif(rclcpp::ok()){An action server requires 6 things:The templated action type name:Fibonacci.A ROS 2 node to add the action to:this.The action name:'fibonacci'.A callback function for handling goals:handle_goalA callback function for handling cancellation:handle_cancel.A callback function for handling goal accept:handle_accept.The implementation of the various callbacks is done with [lambda expressions](https://en.cppreference.com/w/cpp/language/lambda) within the constructor.
Note that all of the callbacks need to return quickly, otherwise we risk starving the executor.We start with the callback for handling new goals:autohandle_goal=[this](constrclcpp_action::GoalUUID&uuid,std::shared_ptr<constFibonacci::Goal>goal){RCLCPP_INFO(this->get_logger(),"Received goal request with order %d",goal->order);(void)uuid;returnrclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;};This implementation just accepts all goals.Next up is the callback for dealing with cancellation:autohandle_cancel=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Received request to cancel goal");(void)goal_handle;returnrclcpp_action::CancelResponse::ACCEPT;};This implementation just tells the client that it accepted the cancellation.The last of the callbacks accepts a new goal and starts processing it:autohandle_accepted=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){// this needs to return quickly to avoid blocking the executor,// so we declare a lambda function to be called inside a new threadautoexecute_in_thread=[this,goal_handle](){returnthis->execute(goal_handle);};std::thread{execute_in_thread}.detach();};Since the execution is a long-running operation, we spawn off a thread to do the actual work and return fromhandle_acceptedquickly.All further processing and updates are done in theexecutemethod in the new thread:voidexecute(conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Executing goal");rclcpp::Rateloop_rate(1);constautogoal=goal_handle->get_goal();autofeedback=std::make_shared<Fibonacci::Feedback>();auto&sequence=feedback->partial_sequence;sequence.push_back(0);sequence.push_back(1);autoresult=std::make_shared<Fibonacci::Result>();for(inti=1;(i<goal->order)&&rclcpp::ok();++i){// Check if there is a cancel requestif(goal_handle->is_canceling()){result->sequence=sequence;goal_handle->canceled(result);RCLCPP_INFO(this->get_logger(),"Goal canceled");return;}// Update sequencesequence.push_back(sequence[i]+sequence[i-1]);// Publish feedbackgoal_handle->publish_feedback(feedback);RCLCPP_INFO(this->get_logger(),"Publish feedback");loop_rate.sleep();}// Check if goal is doneif(rclcpp::ok()){result->sequence=sequence;goal_handle->succeed(result);RCLCPP_INFO(this->get_logger(),"Goal succeeded");}};This work thread processes one sequence number of the Fibonacci sequence every second, publishing a feedback update for each step.
When it has finished processing, it marks thegoal_handleas succeeded, and quits.We now have a fully functioning action server.  Let’s get it built and running.2.2 Compiling the action serverIn the previous section we put the action server code into place.
To get it to compile and run, we need to do a couple of additional things.First we need to setup the CMakeLists.txt so that the action server is compiled.
Open upcustom_action_cpp/CMakeLists.txt, and add the following right after thefind_packagecalls:add_library(action_serverSHAREDsrc/fibonacci_action_server.cpp)target_include_directories(action_serverPRIVATE$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>$<INSTALL_INTERFACE:include>)target_compile_definitions(action_serverPRIVATE"CUSTOM_ACTION_CPP_BUILDING_DLL")ament_target_dependencies(action_server"custom_action_interfaces""rclcpp""rclcpp_action""rclcpp_components")rclcpp_components_register_node(action_serverPLUGIN"custom_action_cpp::FibonacciActionServer"EXECUTABLEfibonacci_action_server)install(TARGETSaction_serverARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)And now we can compile the package.  Go to the top-level of theros2_ws, and run:colconbuildThis should compile the entire workspace, including thefibonacci_action_serverin thecustom_action_cpppackage.2.3 Running the action serverNow that we have the action server built, we can run it.
Source the workspace we just built (ros2_ws), and try to run the action server:ros2runcustom_action_cppfibonacci_action_server3 Writing an action client3.1 Writing the action client codeOpen upcustom_action_cpp/src/fibonacci_action_client.cpp, and put the following code in:#include<functional>#include<future>#include<memory>#include<string>#include<sstream>#include"custom_action_interfaces/action/fibonacci.hpp"#include"rclcpp/rclcpp.hpp"#include"rclcpp_action/rclcpp_action.hpp"#include"rclcpp_components/register_node_macro.hpp"namespacecustom_action_cpp{classFibonacciActionClient:publicrclcpp::Node{public:usingFibonacci=custom_action_interfaces::action::Fibonacci;usingGoalHandleFibonacci=rclcpp_action::ClientGoalHandle<Fibonacci>;explicitFibonacciActionClient(constrclcpp::NodeOptions&options):Node("fibonacci_action_client",options){this->client_ptr_=rclcpp_action::create_client<Fibonacci>(this,"fibonacci");autotimer_callback_lambda=[this](){returnthis->send_goal();};this->timer_=this->create_wall_timer(std::chrono::milliseconds(500),timer_callback_lambda);}voidsend_goal(){usingnamespacestd::placeholders;this->timer_->cancel();if(!this->client_ptr_->wait_for_action_server()){RCLCPP_ERROR(this->get_logger(),"Action server not available after waiting");rclcpp::shutdown();}autogoal_msg=Fibonacci::Goal();goal_msg.order=10;RCLCPP_INFO(this->get_logger(),"Sending goal");autosend_goal_options=rclcpp_action::Client<Fibonacci>::SendGoalOptions();send_goal_options.goal_response_callback=[this](constGoalHandleFibonacci::SharedPtr&goal_handle){if(!goal_handle){RCLCPP_ERROR(this->get_logger(),"Goal was rejected by server");}else{RCLCPP_INFO(this->get_logger(),"Goal accepted by server, waiting for result");}};send_goal_options.feedback_callback=[this](GoalHandleFibonacci::SharedPtr,conststd::shared_ptr<constFibonacci::Feedback>feedback){std::stringstreamss;ss<<"Next number in sequence received: ";for(autonumber:feedback->partial_sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());};send_goal_options.result_callback=[this](constGoalHandleFibonacci::WrappedResult&result){switch(result.code){caserclcpp_action::ResultCode::SUCCEEDED:break;caserclcpp_action::ResultCode::ABORTED:RCLCPP_ERROR(this->get_logger(),"Goal was aborted");return;caserclcpp_action::ResultCode::CANCELED:RCLCPP_ERROR(this->get_logger(),"Goal was canceled");return;default:RCLCPP_ERROR(this->get_logger(),"Unknown result code");return;}std::stringstreamss;ss<<"Result received: ";for(autonumber:result.result->sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());rclcpp::shutdown();};this->client_ptr_->async_send_goal(goal_msg,send_goal_options);}private:rclcpp_action::Client<Fibonacci>::SharedPtrclient_ptr_;rclcpp::TimerBase::SharedPtrtimer_;};// class FibonacciActionClient}// namespace custom_action_cppRCLCPP_COMPONENTS_REGISTER_NODE(custom_action_cpp::FibonacciActionClient)The first few lines include all of the headers we need to compile.Next we create a class that is a derived class ofrclcpp::Node:classFibonacciActionClient:publicrclcpp::NodeThe constructor for theFibonacciActionClientclass initializes the node name asfibonacci_action_client:explicitFibonacciActionClient(constrclcpp::NodeOptions&options):Node("fibonacci_action_client",options)The constructor also instantiates a new action client:this->client_ptr_=rclcpp_action::create_client<Fibonacci>(this,"fibonacci");An action client requires 3 things:The templated action type name:Fibonacci.A ROS 2 node to add the action client to:this.The action name:'fibonacci'.We also instantiate a ROS timer that will kick off the one and only call tosend_goal:autotimer_callback_lambda=[this](){returnthis->send_goal();};this->timer_=this->create_wall_timer(std::chrono::milliseconds(500),timer_callback_lambda);When the timer expires, it will callsend_goal:voidsend_goal(){usingnamespacestd::placeholders;this->timer_->cancel();if(!this->client_ptr_->wait_for_action_server()){RCLCPP_ERROR(this->get_logger(),"Action server not available after waiting");rclcpp::shutdown();}autogoal_msg=Fibonacci::Goal();goal_msg.order=10;RCLCPP_INFO(this->get_logger(),"Sending goal");autosend_goal_options=rclcpp_action::Client<Fibonacci>::SendGoalOptions();send_goal_options.goal_response_callback=[this](constGoalHandleFibonacci::SharedPtr&goal_handle){if(!goal_handle){RCLCPP_ERROR(this->get_logger(),"Goal was rejected by server");}else{RCLCPP_INFO(this->get_logger(),"Goal accepted by server, waiting for result");}};send_goal_options.feedback_callback=[this](GoalHandleFibonacci::SharedPtr,conststd::shared_ptr<constFibonacci::Feedback>feedback){std::stringstreamss;ss<<"Next number in sequence received: ";for(autonumber:feedback->partial_sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());};send_goal_options.result_callback=[this](constGoalHandleFibonacci::WrappedResult&result){switch(result.code){caserclcpp_action::ResultCode::SUCCEEDED:break;caserclcpp_action::ResultCode::ABORTED:RCLCPP_ERROR(this->get_logger(),"Goal was aborted");return;caserclcpp_action::ResultCode::CANCELED:RCLCPP_ERROR(this->get_logger(),"Goal was canceled");return;default:RCLCPP_ERROR(this->get_logger(),"Unknown result code");return;}std::stringstreamss;ss<<"Result received: ";for(autonumber:result.result->sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());rclcpp::shutdown();};this->client_ptr_->async_send_goal(goal_msg,send_goal_options);}This function does the following:Cancels the timer (so it is only called once).Waits for the action server to come up.Instantiates a newFibonacci::Goal.Sets the response, feedback, and result callbacks.Sends the goal to the server.When the server receives and accepts the goal, it will send a response to the client.
That response is handled bygoal_response_callback:send_goal_options.goal_response_callback=[this](constGoalHandleFibonacci::SharedPtr&goal_handle){if(!goal_handle){RCLCPP_ERROR(this->get_logger(),"Goal was rejected by server");}else{RCLCPP_INFO(this->get_logger(),"Goal accepted by server, waiting for result");}};Assuming the goal was accepted by the server, it will start processing.
Any feedback to the client will be handled by thefeedback_callback:send_goal_options.feedback_callback=[this](GoalHandleFibonacci::SharedPtr,conststd::shared_ptr<constFibonacci::Feedback>feedback){std::stringstreamss;ss<<"Next number in sequence received: ";for(autonumber:feedback->partial_sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());};When the server is finished processing, it will return a result to the client.
The result is handled by theresult_callback:send_goal_options.result_callback=[this](constGoalHandleFibonacci::WrappedResult&result){switch(result.code){caserclcpp_action::ResultCode::SUCCEEDED:break;caserclcpp_action::ResultCode::ABORTED:RCLCPP_ERROR(this->get_logger(),"Goal was aborted");return;caserclcpp_action::ResultCode::CANCELED:RCLCPP_ERROR(this->get_logger(),"Goal was canceled");return;default:RCLCPP_ERROR(this->get_logger(),"Unknown result code");return;}std::stringstreamss;ss<<"Result received: ";for(autonumber:result.result->sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());rclcpp::shutdown();};We now have a fully functioning action client.  Let’s get it built and running.3.2 Compiling the action clientIn the previous section we put the action client code into place.
To get it to compile and run, we need to do a couple of additional things.First we need to setup the CMakeLists.txt so that the action client is compiled.
Open upcustom_action_cpp/CMakeLists.txt, and add the following right after thefind_packagecalls:add_library(action_clientSHAREDsrc/fibonacci_action_client.cpp)target_include_directories(action_clientPRIVATE$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>$<INSTALL_INTERFACE:include>)target_compile_definitions(action_clientPRIVATE"CUSTOM_ACTION_CPP_BUILDING_DLL")ament_target_dependencies(action_client"custom_action_interfaces""rclcpp""rclcpp_action""rclcpp_components")rclcpp_components_register_node(action_clientPLUGIN"custom_action_cpp::FibonacciActionClient"EXECUTABLEfibonacci_action_client)install(TARGETSaction_clientARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)And now we can compile the package.  Go to the top-level of theros2_ws, and run:colconbuildThis should compile the entire workspace, including thefibonacci_action_clientin thecustom_action_cpppackage.3.3 Running the action clientNow that we have the action client built, we can run it.
First make sure that an action server is running in a separate terminal.
Now source the workspace we just built (ros2_ws), and try to run the action client:ros2runcustom_action_cppfibonacci_action_clientYou should see logged messages for the goal being accepted, feedback being printed, and the final result.SummaryIn this tutorial, you put together a C++ action server and action client line by line, and configured them to exchange goals, feedback, and results.Related contentThere are several ways you could write an action server and client in C++; check out theminimal_action_serverandminimal_action_clientpackages in theros2/examplesrepo.For more detailed information about ROS actions, please refer to thedesign article.

Code Examples:

Language: unknown
cd~/ros2_ws/src
ros2pkgcreate--dependenciescustom_action_interfacesrclcpprclcpp_actionrclcpp_components--licenseApache-2.0--custom_action_cpp

Language: unknown
cd~/ros2_ws/src
ros2pkgcreate--dependenciescustom_action_interfacesrclcpprclcpp_actionrclcpp_components--licenseApache-2.0--custom_action_cpp

Language: unknown
cd\ros2_ws\src
ros2pkgcreate--dependenciescustom_action_interfacesrclcpprclcpp_actionrclcpp_components--licenseApache-2.0--custom_action_cpp

Language: unknown
#ifndef CUSTOM_ACTION_CPP__VISIBILITY_CONTROL_H_#define CUSTOM_ACTION_CPP__VISIBILITY_CONTROL_H_#ifdef __cplusplusextern"C"{#endif// This logic was borrowed (then namespaced) from the examples on the gcc wiki://     https://gcc.gnu.org/wiki/Visibility#if defined _WIN32 || defined __CYGWIN__#ifdef __GNUC__#define CUSTOM_ACTION_CPP_EXPORT __attribute__ ((dllexport))#define CUSTOM_ACTION_CPP_IMPORT __attribute__ ((dllimport))#else#define CUSTOM_ACTION_CPP_EXPORT __declspec(dllexport)#define CUSTOM_ACTION_CPP_IMPORT __declspec(dllimport)#endif#ifdef CUSTOM_ACTION_CPP_BUILDING_DLL#define CUSTOM_ACTION_CPP_PUBLIC CUSTOM_ACTION_CPP_EXPORT#else#define CUSTOM_ACTION_CPP_PUBLIC CUSTOM_ACTION_CPP_IMPORT#endif#define CUSTOM_ACTION_CPP_PUBLIC_TYPE CUSTOM_ACTION_CPP_PUBLIC#define CUSTOM_ACTION_CPP_LOCAL#else#define CUSTOM_ACTION_CPP_EXPORT __attribute__ ((visibility("default")))#define CUSTOM_ACTION_CPP_IMPORT#if __GNUC__ >= 4#define CUSTOM_ACTION_CPP_PUBLIC __attribute__ ((visibility("default")))#define CUSTOM_ACTION_CPP_LOCAL  __attribute__ ((visibility("hidden")))#else#define CUSTOM_ACTION_CPP_PUBLIC#define CUSTOM_ACTION_CPP_LOCAL#endif#define CUSTOM_ACTION_CPP_PUBLIC_TYPE#endif#ifdef __cplusplus}#endif#endif// CUSTOM_ACTION_CPP__VISIBILITY_CONTROL_H_

Language: unknown
#include<functional>#include<memory>#include<thread>#include"custom_action_interfaces/action/fibonacci.hpp"#include"rclcpp/rclcpp.hpp"#include"rclcpp_action/rclcpp_action.hpp"#include"rclcpp_components/register_node_macro.hpp"#include"custom_action_cpp/visibility_control.h"namespacecustom_action_cpp{classFibonacciActionServer:publicrclcpp::Node{public:usingFibonacci=custom_action_interfaces::action::Fibonacci;usingGoalHandleFibonacci=rclcpp_action::ServerGoalHandle<Fibonacci>;CUSTOM_ACTION_CPP_PUBLICexplicitFibonacciActionServer(constrclcpp::NodeOptions&options=rclcpp::NodeOptions()):Node("fibonacci_action_server",options){usingnamespacestd::placeholders;autohandle_goal=[this](constrclcpp_action::GoalUUID&uuid,std::shared_ptr<constFibonacci::Goal>goal){RCLCPP_INFO(this->get_logger(),"Received goal request with order %d",goal->order);(void)uuid;returnrclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;};autohandle_cancel=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Received request to cancel goal");(void)goal_handle;returnrclcpp_action::CancelResponse::ACCEPT;};autohandle_accepted=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){// this needs to return quickly to avoid blocking the executor,// so we declare a lambda function to be called inside a new threadautoexecute_in_thread=[this,goal_handle](){returnthis->execute(goal_handle);};std::thread{execute_in_thread}.detach();};this->action_server_=rclcpp_action::create_server<Fibonacci>(this,"fibonacci",handle_goal,handle_cancel,handle_accepted);}private:rclcpp_action::Server<Fibonacci>::SharedPtraction_server_;voidexecute(conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Executing goal");rclcpp::Rateloop_rate(1);constautogoal=goal_handle->get_goal();autofeedback=std::make_shared<Fibonacci::Feedback>();auto&sequence=feedback->partial_sequence;sequence.push_back(0);sequence.push_back(1);autoresult=std::make_shared<Fibonacci::Result>();for(inti=1;(i<goal->order)&&rclcpp::ok();++i){// Check if there is a cancel requestif(goal_handle->is_canceling()){result->sequence=sequence;goal_handle->canceled(result);RCLCPP_INFO(this->get_logger(),"Goal canceled");return;}// Update sequencesequence.push_back(sequence[i]+sequence[i-1]);// Publish feedbackgoal_handle->publish_feedback(feedback);RCLCPP_INFO(this->get_logger(),"Publish feedback");loop_rate.sleep();}// Check if goal is doneif(rclcpp::ok()){result->sequence=sequence;goal_handle->succeed(result);RCLCPP_INFO(this->get_logger(),"Goal succeeded");}};};// class FibonacciActionServer}// namespace custom_action_cppRCLCPP_COMPONENTS_REGISTER_NODE(custom_action_cpp::FibonacciActionServer)

Language: unknown
classFibonacciActionServer:publicrclcpp::Node

Language: unknown
explicitFibonacciActionServer(constrclcpp::NodeOptions&options=rclcpp::NodeOptions()):Node("fibonacci_action_server",options)

Language: unknown
loop_rate.sleep();}// Check if goal is doneif(rclcpp::ok()){

Language: unknown
autohandle_goal=[this](constrclcpp_action::GoalUUID&uuid,std::shared_ptr<constFibonacci::Goal>goal){RCLCPP_INFO(this->get_logger(),"Received goal request with order %d",goal->order);(void)uuid;returnrclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;};

Language: unknown
autohandle_cancel=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Received request to cancel goal");(void)goal_handle;returnrclcpp_action::CancelResponse::ACCEPT;};

Language: unknown
autohandle_accepted=[this](conststd::shared_ptr<GoalHandleFibonacci>goal_handle){// this needs to return quickly to avoid blocking the executor,// so we declare a lambda function to be called inside a new threadautoexecute_in_thread=[this,goal_handle](){returnthis->execute(goal_handle);};std::thread{execute_in_thread}.detach();};

Language: unknown
voidexecute(conststd::shared_ptr<GoalHandleFibonacci>goal_handle){RCLCPP_INFO(this->get_logger(),"Executing goal");rclcpp::Rateloop_rate(1);constautogoal=goal_handle->get_goal();autofeedback=std::make_shared<Fibonacci::Feedback>();auto&sequence=feedback->partial_sequence;sequence.push_back(0);sequence.push_back(1);autoresult=std::make_shared<Fibonacci::Result>();for(inti=1;(i<goal->order)&&rclcpp::ok();++i){// Check if there is a cancel requestif(goal_handle->is_canceling()){result->sequence=sequence;goal_handle->canceled(result);RCLCPP_INFO(this->get_logger(),"Goal canceled");return;}// Update sequencesequence.push_back(sequence[i]+sequence[i-1]);// Publish feedbackgoal_handle->publish_feedback(feedback);RCLCPP_INFO(this->get_logger(),"Publish feedback");loop_rate.sleep();}// Check if goal is doneif(rclcpp::ok()){result->sequence=sequence;goal_handle->succeed(result);RCLCPP_INFO(this->get_logger(),"Goal succeeded");}};

Language: unknown
add_library(action_serverSHAREDsrc/fibonacci_action_server.cpp)target_include_directories(action_serverPRIVATE$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>$<INSTALL_INTERFACE:include>)target_compile_definitions(action_serverPRIVATE"CUSTOM_ACTION_CPP_BUILDING_DLL")ament_target_dependencies(action_server"custom_action_interfaces""rclcpp""rclcpp_action""rclcpp_components")rclcpp_components_register_node(action_serverPLUGIN"custom_action_cpp::FibonacciActionServer"EXECUTABLEfibonacci_action_server)install(TARGETSaction_serverARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)

Language: unknown
colconbuild

Language: unknown
ros2runcustom_action_cppfibonacci_action_server

Language: unknown
#include<functional>#include<future>#include<memory>#include<string>#include<sstream>#include"custom_action_interfaces/action/fibonacci.hpp"#include"rclcpp/rclcpp.hpp"#include"rclcpp_action/rclcpp_action.hpp"#include"rclcpp_components/register_node_macro.hpp"namespacecustom_action_cpp{classFibonacciActionClient:publicrclcpp::Node{public:usingFibonacci=custom_action_interfaces::action::Fibonacci;usingGoalHandleFibonacci=rclcpp_action::ClientGoalHandle<Fibonacci>;explicitFibonacciActionClient(constrclcpp::NodeOptions&options):Node("fibonacci_action_client",options){this->client_ptr_=rclcpp_action::create_client<Fibonacci>(this,"fibonacci");autotimer_callback_lambda=[this](){returnthis->send_goal();};this->timer_=this->create_wall_timer(std::chrono::milliseconds(500),timer_callback_lambda);}voidsend_goal(){usingnamespacestd::placeholders;this->timer_->cancel();if(!this->client_ptr_->wait_for_action_server()){RCLCPP_ERROR(this->get_logger(),"Action server not available after waiting");rclcpp::shutdown();}autogoal_msg=Fibonacci::Goal();goal_msg.order=10;RCLCPP_INFO(this->get_logger(),"Sending goal");autosend_goal_options=rclcpp_action::Client<Fibonacci>::SendGoalOptions();send_goal_options.goal_response_callback=[this](constGoalHandleFibonacci::SharedPtr&goal_handle){if(!goal_handle){RCLCPP_ERROR(this->get_logger(),"Goal was rejected by server");}else{RCLCPP_INFO(this->get_logger(),"Goal accepted by server, waiting for result");}};send_goal_options.feedback_callback=[this](GoalHandleFibonacci::SharedPtr,conststd::shared_ptr<constFibonacci::Feedback>feedback){std::stringstreamss;ss<<"Next number in sequence received: ";for(autonumber:feedback->partial_sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());};send_goal_options.result_callback=[this](constGoalHandleFibonacci::WrappedResult&result){switch(result.code){caserclcpp_action::ResultCode::SUCCEEDED:break;caserclcpp_action::ResultCode::ABORTED:RCLCPP_ERROR(this->get_logger(),"Goal was aborted");return;caserclcpp_action::ResultCode::CANCELED:RCLCPP_ERROR(this->get_logger(),"Goal was canceled");return;default:RCLCPP_ERROR(this->get_logger(),"Unknown result code");return;}std::stringstreamss;ss<<"Result received: ";for(autonumber:result.result->sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());rclcpp::shutdown();};this->client_ptr_->async_send_goal(goal_msg,send_goal_options);}private:rclcpp_action::Client<Fibonacci>::SharedPtrclient_ptr_;rclcpp::TimerBase::SharedPtrtimer_;};// class FibonacciActionClient}// namespace custom_action_cppRCLCPP_COMPONENTS_REGISTER_NODE(custom_action_cpp::FibonacciActionClient)

Language: unknown
classFibonacciActionClient:publicrclcpp::Node

Language: unknown
explicitFibonacciActionClient(constrclcpp::NodeOptions&options):Node("fibonacci_action_client",options)

Language: unknown
this->client_ptr_=rclcpp_action::create_client<Fibonacci>(this,"fibonacci");

Language: unknown
autotimer_callback_lambda=[this](){returnthis->send_goal();};this->timer_=this->create_wall_timer(std::chrono::milliseconds(500),timer_callback_lambda);

Language: unknown
voidsend_goal(){usingnamespacestd::placeholders;this->timer_->cancel();if(!this->client_ptr_->wait_for_action_server()){RCLCPP_ERROR(this->get_logger(),"Action server not available after waiting");rclcpp::shutdown();}autogoal_msg=Fibonacci::Goal();goal_msg.order=10;RCLCPP_INFO(this->get_logger(),"Sending goal");autosend_goal_options=rclcpp_action::Client<Fibonacci>::SendGoalOptions();send_goal_options.goal_response_callback=[this](constGoalHandleFibonacci::SharedPtr&goal_handle){if(!goal_handle){RCLCPP_ERROR(this->get_logger(),"Goal was rejected by server");}else{RCLCPP_INFO(this->get_logger(),"Goal accepted by server, waiting for result");}};send_goal_options.feedback_callback=[this](GoalHandleFibonacci::SharedPtr,conststd::shared_ptr<constFibonacci::Feedback>feedback){std::stringstreamss;ss<<"Next number in sequence received: ";for(autonumber:feedback->partial_sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());};send_goal_options.result_callback=[this](constGoalHandleFibonacci::WrappedResult&result){switch(result.code){caserclcpp_action::ResultCode::SUCCEEDED:break;caserclcpp_action::ResultCode::ABORTED:RCLCPP_ERROR(this->get_logger(),"Goal was aborted");return;caserclcpp_action::ResultCode::CANCELED:RCLCPP_ERROR(this->get_logger(),"Goal was canceled");return;default:RCLCPP_ERROR(this->get_logger(),"Unknown result code");return;}std::stringstreamss;ss<<"Result received: ";for(autonumber:result.result->sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());rclcpp::shutdown();};this->client_ptr_->async_send_goal(goal_msg,send_goal_options);}

Language: unknown
send_goal_options.goal_response_callback=[this](constGoalHandleFibonacci::SharedPtr&goal_handle){if(!goal_handle){RCLCPP_ERROR(this->get_logger(),"Goal was rejected by server");}else{RCLCPP_INFO(this->get_logger(),"Goal accepted by server, waiting for result");}};

Language: unknown
send_goal_options.feedback_callback=[this](GoalHandleFibonacci::SharedPtr,conststd::shared_ptr<constFibonacci::Feedback>feedback){std::stringstreamss;ss<<"Next number in sequence received: ";for(autonumber:feedback->partial_sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());};

Language: unknown
send_goal_options.result_callback=[this](constGoalHandleFibonacci::WrappedResult&result){switch(result.code){caserclcpp_action::ResultCode::SUCCEEDED:break;caserclcpp_action::ResultCode::ABORTED:RCLCPP_ERROR(this->get_logger(),"Goal was aborted");return;caserclcpp_action::ResultCode::CANCELED:RCLCPP_ERROR(this->get_logger(),"Goal was canceled");return;default:RCLCPP_ERROR(this->get_logger(),"Unknown result code");return;}std::stringstreamss;ss<<"Result received: ";for(autonumber:result.result->sequence){ss<<number<<" ";}RCLCPP_INFO(this->get_logger(),ss.str().c_str());rclcpp::shutdown();};

Language: unknown
add_library(action_clientSHAREDsrc/fibonacci_action_client.cpp)target_include_directories(action_clientPRIVATE$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>$<INSTALL_INTERFACE:include>)target_compile_definitions(action_clientPRIVATE"CUSTOM_ACTION_CPP_BUILDING_DLL")ament_target_dependencies(action_client"custom_action_interfaces""rclcpp""rclcpp_action""rclcpp_components")rclcpp_components_register_node(action_clientPLUGIN"custom_action_cpp::FibonacciActionClient"EXECUTABLEfibonacci_action_client)install(TARGETSaction_clientARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)

Language: unknown
colconbuild

Language: unknown
ros2runcustom_action_cppfibonacci_action_client
