Title: Dashing Diademata (dashing)
URL: https://docs.ros.org/en/jazzy/Releases/Release-Dashing-Diademata.html
Section: Installation
--------------------------------------------------------------------------------

Dashing Diademata (dashing)Table of ContentsSupported PlatformsInstallationNew features in this ROS 2 releaseChanges since the Crystal releaseDeclaring Parametersament_cmakerclcpprclcpp_componentsrclpyrosidlrosidl_generator_cpprosidl_generator_pylaunchrmwactionsrvizKnown IssuesTimeline before the releaseDashing Diadematais the fourth release of ROS 2.Supported PlatformsDashing Diademata is primarily supported on the following platforms:Tier 1 platforms:Ubuntu 18.04 (Bionic):amd64andarm64Mac macOS 10.12 (Sierra)Windows 10 (Visual Studio 2019)Tier 2 platforms:Ubuntu 18.04 (Bionic):arm32Tier 3 platforms:Debian Stretch (9):amd64,arm64andarm32OpenEmbedded Thud (2.6) / webOS OSE:arm32andx86For more information about RMW implementations, compiler / interpreter versions, and system dependency versions seeREP 2000.InstallationInstall Dashing DiademataNew features in this ROS 2 releaseA few features and improvements we would like to highlight:Componentsare now the recommended way to write your node.
They can be used standalone as well as being composed within a process and both ways are fully support fromlaunchfiles.Theintra-process communication(C++ only) has been improved - both in terms of latency as well as minimizing copies.The Python client library has been updated to match most of the C++ equivalent and some important bug fixes and improvements have landed related to memory usage and performance.Parameters are now a complete alternative todynamic_reconfigurefrom ROS 1 including constraints like ranges or being read-only.By relying on (a subset of)IDL 4.2for the message generation pipeline it is now possible to use.idlfiles (beside.msg/.srv/.actionfiles).
This change comes with support for optional UTF-8 encoding for ordinary strings as well as UTF-16 encoded multi-byte strings (seewide strings design article).Command line tools related toactionsandcomponents.Support for Deadline, Lifespan & Liveliness quality of service settings.MoveIt 2alpha release.Please see theDashing meta ticketon GitHub, which contains more information as well as references to specific tickets with additional details.Changes since the Crystal releaseDeclaring ParametersThere have been some changes to the behavior of parameters starting in Dashing, which have also lead to some new API’s and the deprecation of other API’s.
See therclcppandrclpysections below for more information about API changes.Getting and Setting Undeclared ParametersAs of Dashing, parameters now need to be declared before being accessed or set.Before Dashing, you could callget_parameter(name)and get either a value, if it had been previously set, or a parameter of typePARAMETER_NOT_SET.
You could also callset_parameter(name,value)at any point, even if the parameter was previously unset.Since Dashing, you need to first declare a parameter before getting or setting it.
If you try to get or set an undeclared parameter you will either get an exception thrown, e.g. ParameterNotDeclaredException, or in certain cases you will get an unsuccessful result communicated in a variety of ways (see specific functions for more details).However, you can get the old behavior (mostly, see the note in the next paragraph) by using theallow_undeclared_parametersoption when creating your node.
You might want to do this in order to avoid code changes for now, or in order to fulfill some uncommon use cases.
For example, a “global parameter server” or “parameter blackboard” may want to allow external nodes to set new parameters on itself without first declaring them, so it may use theallow_undeclared_parametersoption to accomplish that.
In most cases, however, this option is not recommended because it makes the rest of the parameter API less safe to bugs like parameter name typos and “use before set” logical errors.Note that usingallow_undeclared_parameterswill get you most of the old behavior specifically for “get” and “set” methods, but it will not revert all the behavior changes related to parameters back to how it was for ROS Crystal.
For that you need to also set theautomatically_declare_parameters_from_overridesoption totrue, which is described below inParameter Configuration using a YAML File.Declaring a Parameter with a ParameterDescriptorAnother benefit to declaring your parameters before using them, is that it allows you to declare a parameter descriptor at the same time.Now when declaring a parameter you may include a customParameterDescriptoras well as a name and default value.
TheParameterDescriptoris defined as a message inrcl_interfaces/msg/ParameterDescriptorand contains meta data likedescriptionand constraints likeread_onlyorinteger_range.
These constraints can be used to reject invalid values when setting parameters and/or as hints to external tools about what values are valid for a given parameter.
Theread_onlyconstraint will prevent the parameter’s value from changing after being declared, as well as prevent if from being undeclared.For reference, here’s a link to theParameterDescriptormessage as of the time of writing this:https://github.com/ros2/rcl_interfaces/blob/0aba5a142878c2077d7a03977087e7d74d40ee68/rcl_interfaces/msg/ParameterDescriptor.msg#L1Parameter Configuration using a YAML FileAs of Dashing, parameters in a YAML configuration file, e.g. passed to the node via the command line argument__params:=, are only used to override a parameter’s default value when declaring the parameter.Before Dashing, any parameters you passed via a YAML file would be implicitly set on the node.Since Dashing, this is no longer the case, as parameters need to be declared in order to appear on the node to external observers, likeros2paramlist.The old behavior may be achieved using theautomatically_declare_parameters_from_overridesoption when creating a node.
This option, if set totrue, will automatically declare all parameters in the input YAML file when the node is constructed.
This may be used to avoid major changes to your existing code or to serve specific use cases.
For example, a “global parameter server” may want to be seeded with arbitrary parameters on launch, which it could not have declared ahead of time.
Most of the time, however, this option is not recommended, as it may lead to setting a parameter in a YAML file with the assumption that the node will use it, even if the node does not actually use it.In the future we hope to have a checker that will warn you if you pass a parameter to a node that it was not expecting.The parameters in the YAML file will continue to influence the value of parameters when they are first declared.ament_cmakeThe CMake functionament_index_has_resourcewas returning eitherTRUEorFALSE.
As ofthis releaseit returns either the prefix path in case the resource was found orFALSE.If you are using the return value in a CMake condition like this:ament_index_has_resource(var...)if(${var})you need to update the condition to ensure it considers a string value asTRUE:if(var)rclcppBehavior Change forNode::get_node_names()The functionNodeGraph::get_node_names(), and therefore alsoNode::get_node_names(), now returns astd::vector<std::string>containing fully qualified node names with their namespaces included, instead of just the node names.Changed the Way that Options are Passed to NodesExtended arguments (beyond name and namespace) to therclcpp::Node()constructor have been replaced with arclcpp::NodeOptionsstructure.
Seeros2/rclcpp#622for details about the structure and default values of the options.If you are using any of the extended arguments torclcpp::Node()like this:autocontext=rclcpp::contexts::default_context::get_global_default_context();std::vector<std::string>args;std::vector<rclcpp::Parameter>params={rclcpp::Parameter("use_sim_time",true)};autonode=std::make_shared<rclcpp::Node>("foo_node","bar_namespace",context,args,params);You need to update to use theNodeOptionsstructurestd::vector<std::string>args;std::vector<rclcpp::Parameter>params={rclcpp::Parameter("use_sim_time",true)};rclcpp::NodeOptionsnode_options;node_options.arguments(args);node_options.parameter_overrides(params);autonode=std::make_shared<rclcpp::Node>("foo_node","bar_namespace",node_options);Changes to Creating Publishers and SubscriptionsThere have been a few changes to creating publishers and subscriptions which are new in Dashing:QoS settings are now passed using the newrclcpp::QoSclass, and the API encourages the user to specify at least the history depth.Options are now passed as an object, i.e.rclcpp::PublisherOptionsandrclcpp::SubscriptionOptions.All changes are backwards compatible (no code changes are required), but several existing call styles have been deprecated.
Users are encouraged to update to the new signatures.In the past, when creating a publisher or subscription, you could either not specify any QoS settings (e.g. just provide topic name for a publisher) or you could specify a “qos profile” data structure (of typermw_qos_profile_t) with all the settings already set.
Now you must use the newrclcpp::QoSobject to specify your QoS and at least the history settings for your QoS.
This encourages the user to specify a history depth when usingKEEP_LAST, rather than defaulting it to a value that may or may not be appropriate.In ROS 1, this was known as thequeue_sizeand it was required in both C++ and Python.
We’re changing the ROS 2 API to bring this requirement back.Also, any options which could previously be passed during creation of a publisher or subscription have now been encapsulated in anrclcpp::PublisherOptionsandrclcpp::SubscriptionOptionsclass respectively.
This allows for shorter signatures, more convenient use, and for adding new future options without breaking API.Some signatures for creating publishers and subscribers are now deprecated, and new signatures have been added to allow you to use the newrclcpp::QoSand publisher/subscription option classes.These are the new and recommended API’s:template<typenameMessageT,typenameAllocatorT=std::allocator<void>,typenamePublisherT=::rclcpp::Publisher<MessageT,AllocatorT>>std::shared_ptr<PublisherT>create_publisher(conststd::string&topic_name,constrclcpp::QoS&qos,constPublisherOptionsWithAllocator<AllocatorT>&options=PublisherOptionsWithAllocator<AllocatorT>());template<typenameMessageT,typenameCallbackT,typenameAllocatorT=std::allocator<void>,typenameSubscriptionT=rclcpp::Subscription<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,AllocatorT>>std::shared_ptr<SubscriptionT>create_subscription(conststd::string&topic_name,constrclcpp::QoS&qos,CallbackT&&callback,constSubscriptionOptionsWithAllocator<AllocatorT>&options=SubscriptionOptionsWithAllocator<AllocatorT>(),typenamerclcpp::message_memory_strategy::MessageMemoryStrategy<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,AllocatorT>::SharedPtrmsg_mem_strat=nullptr);And these are the deprecated ones:template<typenameMessageT,typenameAllocatorT=std::allocator<void>,typenamePublisherT=::rclcpp::Publisher<MessageT,AllocatorT>>[[deprecated("use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead")]]std::shared_ptr<PublisherT>create_publisher(conststd::string&topic_name,size_tqos_history_depth,std::shared_ptr<AllocatorT>allocator);template<typenameMessageT,typenameAllocatorT=std::allocator<void>,typenamePublisherT=::rclcpp::Publisher<MessageT,AllocatorT>>[[deprecated("use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead")]]std::shared_ptr<PublisherT>create_publisher(conststd::string&topic_name,constrmw_qos_profile_t&qos_profile=rmw_qos_profile_default,std::shared_ptr<AllocatorT>allocator=nullptr);template<typenameMessageT,typenameCallbackT,typenameAlloc=std::allocator<void>,typenameSubscriptionT=rclcpp::Subscription<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>>[[deprecated("use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead")]]std::shared_ptr<SubscriptionT>create_subscription(conststd::string&topic_name,CallbackT&&callback,constrmw_qos_profile_t&qos_profile=rmw_qos_profile_default,rclcpp::callback_group::CallbackGroup::SharedPtrgroup=nullptr,boolignore_local_publications=false,typenamerclcpp::message_memory_strategy::MessageMemoryStrategy<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>::SharedPtrmsg_mem_strat=nullptr,std::shared_ptr<Alloc>allocator=nullptr);template<typenameMessageT,typenameCallbackT,typenameAlloc=std::allocator<void>,typenameSubscriptionT=rclcpp::Subscription<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>>[[deprecated("use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead")]]std::shared_ptr<SubscriptionT>create_subscription(conststd::string&topic_name,CallbackT&&callback,size_tqos_history_depth,rclcpp::callback_group::CallbackGroup::SharedPtrgroup=nullptr,boolignore_local_publications=false,typenamerclcpp::message_memory_strategy::MessageMemoryStrategy<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>::SharedPtrmsg_mem_strat=nullptr,std::shared_ptr<Alloc>allocator=nullptr);The change to how QoS is passed is most likely to impact users.A typical change for a publisher looks like this:- pub_ = create_publisher<std_msgs::msg::String>("chatter");+ pub_ = create_publisher<std_msgs::msg::String>("chatter", 10);And for a subscription:- sub_ = create_subscription<std_msgs::msg::String>("chatter", callback);+ sub_ = create_subscription<std_msgs::msg::String>("chatter", 10, callback);If you have no idea what depth to use and don’t care right now (maybe just prototyping), then we recommend using10, as that was the default before and should preserve existing behavior.More in depth documentation about how to select an appropriate depth is forthcoming.This is an example of a slightly more involved change to avoid the newly deprecated API’s:- // Creates a latched topic- rmw_qos_profile_t qos = rmw_qos_profile_default;- qos.depth = 1;- qos.durability = RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL;-model_xml_.data = model_xml;node_handle->declare_parameter("robot_description", model_xml);description_pub_ = node_handle->create_publisher<std_msgs::msg::String>(-   "robot_description", qos);+   "robot_description",+   // Transient local is similar to latching in ROS 1.+   rclcpp::QoS(1).transient_local());See the pull request (and connected pull requests) that introduced the QoS change for more examples and details:https://github.com/ros2/rclcpp/pull/713https://github.com/ros2/demos/pull/332https://github.com/ros2/robot_state_publisher/pull/19and others…Changes Due to Declare Parameter ChangeFor details about the actual behavior change, seeDeclaring Parametersabove.There are several new API calls in therclcpp::Node’s interface:Methods that declare parameters given a name, optional default value, optional descriptor, and return the value actually set:constrclcpp::ParameterValue&rclcpp::Node::declare_parameter(conststd::string&name,constrclcpp::ParameterValue&default_value=rclcpp::ParameterValue(),constrcl_interfaces::msg::ParameterDescriptor&parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor());template<typenameParameterT>autorclcpp::Node::declare_parameter(conststd::string&name,constParameterT&default_value,constrcl_interfaces::msg::ParameterDescriptor&parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor());template<typenameParameterT>std::vector<ParameterT>rclcpp::Node::declare_parameters(conststd::string&namespace_,conststd::map<std::string,ParameterT>&parameters);template<typenameParameterT>std::vector<ParameterT>rclcpp::Node::declare_parameters(conststd::string&namespace_,conststd::map<std::string,std::pair<ParameterT,rcl_interfaces::msg::ParameterDescriptor>>&parameters);A method to undeclare parameters and to check if a parameter has been declared:voidrclcpp::Node::undeclare_parameter(conststd::string&name);boolrclcpp::Node::has_parameter(conststd::string&name)const;Some convenience methods that did not previously exist:rcl_interfaces::msg::SetParametersResultrclcpp::Node::set_parameter(constrclcpp::Parameter&parameter);std::vector<rclcpp::Parameter>rclcpp::Node::get_parameters(conststd::vector<std::string>&names)const;rcl_interfaces::msg::ParameterDescriptorrclcpp::Node::describe_parameter(conststd::string&name)const;A new method to set the callback which is called anytime a parameter will be changed, giving you the opportunity to reject it:usingOnParametersSetCallbackType=rclcpp::node_interfaces::NodeParametersInterface::OnParametersSetCallbackType;OnParametersSetCallbackTyperclcpp::Node::set_on_parameters_set_callback(OnParametersSetCallbackTypecallback);There were also several deprecated methods:template<typenameParameterT>[[deprecated("use declare_parameter() instead")]]voidrclcpp::Node::set_parameter_if_not_set(conststd::string&name,constParameterT&value);template<typenameParameterT>[[deprecated("use declare_parameters() instead")]]voidrclcpp::Node::set_parameters_if_not_set(conststd::string&name,conststd::map<std::string,ParameterT>&values);template<typenameParameterT>[[deprecated("use declare_parameter() and it's return value instead")]]voidrclcpp::Node::get_parameter_or_set(conststd::string&name,ParameterT&value,constParameterT&alternative_value);template<typenameCallbackT>[[deprecated("use set_on_parameters_set_callback() instead")]]voidrclcpp::Node::register_param_change_callback(CallbackT&&callback);Memory StrategyThe interfacerclcpp::memory_strategy::MemoryStrategywas using the typedefWeakNodeVectorin various method signatures.
As of Dashing the typedef has been been changed toWeakNodeListand with it the type of the parameter in various methods.
Any custom memory strategy needs to be updated to match the modified interface.The relevant API change can be found inros2/rclcpp#741.rclcpp_componentsThe correct way to implement composition in Dashing is by utilizing therclcpp_componentspackage.The following changes must be made to nodes in order to correctly implement runtime composition:The Node must have a constructor that takesrclcpp::NodeOptions:classListener:publicrclcpp::Node{Listener(constrclcpp::NodeOptions&options):Node("listener",options){}};C++ registration macros (if present) need to be updated to use therclcpp_componentsequivalent.
If not present, registration macros must be added in one translation unit.// Insert at bottom of translation unit, e.g. listener.cpp#include"rclcpp_components/register_node_macro.hpp"// Use fully-qualifed name in registrationRCLCPP_COMPONENTS_REGISTER_NODE(composition::Listener);CMake registration macros (if present) need to be updated.
If not present, registration macros must be added to the project’s CMake.add_library(listenersrc/listener.cpp)rclcpp_components_register_nodes(listener"composition::Listener")For more information on composition, seethe tutorialrclpyChanges to Creating Publishers, Subscriptions, and QoS ProfilesPrior to Dashing, you could optionally provide aQoSProfileobject when creating a publisher or subscription.
In an effort to encourage users to specify a history depth for message queues, we nowrequirethat a depth value orQoSProfileobject is given when creating publishers or subscriptions.To create a publisher, previously you would have written:node.create_publisher(Empty,'chatter')# Or using a keyword argument for QoSProfilenode.create_publisher(Empty,'chatter',qos_profile=qos_profile_sensor_data)In Dashing, prefer the following API that provides a depth value orQoSProfileobject as a third positional argument:# Assume a history setting of KEEP_LAST with depth 10node.create_publisher(Empty,'chatter',10)# Or pass a QoSProfile object directlynode.create_publisher(Empty,'chatter',qos_profile_sensor_data)Likewise for subscriptions, previously you would have written:node.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg))# Or using a keyword argument for QoSProfilenode.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg),qos_profile=qos_profile_sensor_data)In Dashing:# Assume a history setting of KEEP_LAST with depth 10node.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg),10)# Or pass a QoSProfile object directlynode.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg),qos_profile_sensor_data)To ease the transition, users who do not use the new API will see deprecation warnings.Furthermore, we also require that when constructingQoSProfileobjects that a history policy and/or depth is set.
If a history policy ofKEEP_LASTis provided, then a depth argument is also required.
For example, these calls are valid:QoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_ALL)QoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST,depth=10)QoSProfile(depth=10)# equivalent to the previous lineAnd these calls will cause a deprecation warning:QoSProfile()QoSProfile(reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT)# KEEP_LAST but no depthQoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST)See the issue and pull request related to introducing this change for more details:https://github.com/ros2/rclpy/issues/342https://github.com/ros2/rclpy/pull/344Changes Due to Declare Parameter ChangeFor details about the actual behavior change, seeDeclaring Parametersabove. The changes are analogous to the ones inrclcpp.These are the new API methods available inrclpy.node.Nodeinterface:To declare parameters given a name, an optional default value (supported byrcl_interfaces.msg.ParameterValue) and an optional descriptor, returning the value actually set:defdeclare_parameter(name:str,value:Any=None,descriptor:ParameterDescriptor=ParameterDescriptor())->Parameterdefdeclare_parameters(namespace:str,parameters:List[Union[Tuple[str],Tuple[str,Any],Tuple[str,Any,ParameterDescriptor],]])->List[Parameter]To undeclare previously declared parameters and to check if a parameter has been declared beforehand:defundeclare_parameter(name:str)->Nonedefhas_parameter(name:str)->boolTo get and set parameter descriptors:defdescribe_parameter(name:str)->ParameterDescriptordefdescribe_parameters(names:List[str])->List[ParameterDescriptor]defset_descriptor(name:str,descriptor:ParameterDescriptor,alternative_value:Optional[ParameterValue]=None)->ParameterValueA convenience method to get parameters that may not have been declared:defget_parameter_or(name:str,alternative_value:Optional[Parameter]=None)->ParameterOther changesrclpy.parameter.Parametercan now guess its type without explicitly setting it (as long as it’s one of the supported ones byrcl_interfaces.msg.ParameterValue).
For example, this code:p=Parameter('myparam',Parameter.Type.DOUBLE,2.41)Is equivalent to this code:p=Parameter('myparam',value=2.41)This change does not break existing API.rosidlUntil Crystal each message generator package registered itself using theament_cmakeextension pointrosidl_generate_interfacesand was passed a set of.msg/.srv/.actionfiles.
As of Dashing the message generation pipeline is based on.idlfiles instead.Any message generator package needs to change and register itself using the new extension pointrosidl_generate_idl_interfaceswhich passes only.idlfiles instead.
The message generators for the commonly supported languages C, C++, and Python as well as the typesupport packages for introspection, Fast RTPS, Connext and OpenSplice have already been updated (seeros2/rosidl#334).
The CMake code callingrosidl_generate_interfaces()can either pass.idlfiles directly or pass.msg/.srv/.actionwhich will then internally be converted into.idlfiles before being passed to each message generator.The format of.msg/.srv/.actionfiles is not being evolved in the future.
The mapping between.msg/.srv/.actionfiles and.idlfiles is described inthis design article.
Asecond design articledescribes the supported features in.idlfiles.
In order to leverage any of the new features existing interfaces need to be converted (e.g. using the command line toolsmsg2idl/srv2idl/action2idl).To distinguish same type names, but with different namespaces, the introspection structs now contain a namespace field that replaces the package name (seeros2/rosidl#335).Mapping of char in .msg filesInROS 1charhas been deprecated for a long time and is being mapped touint8.
In ROS 2 until Crystalcharwas mapped to a single character (charin C / C++,strwith length 1 in Python) in an effort to provide a more natural mapping.
As of Dashing the ROS 1 semantic has been restored andcharmaps touint8again.rosidl_generator_cppThe C++ data structures generated for messages, services and actions provide setter methods for each field.
Until Crystal each setter returned a pointer to the data structure itself to enable the named parameter idiom.
As of Dashing these settersreturn a referenceinstead since that seems to be the more common signature as well as it clarifies that the returned value can’t be anullptr.rosidl_generator_pyUntil Crystal an array (fixed size) or sequence (dynamic size, optionally with an upper boundary) field in a message was stored as alistin Python.
As of Dashing the Python type for arrays / sequences of numeric values has been changed:an array of numeric values is stored as anumpy.ndarray(thedtypeis chosen to match the type of the numeric value)a sequence of numeric values is stored as anarray.array(thetypenameis chosen to match the type of the numeric value)As before an array / sequence of non-numeric types is still represented as alistin Python.This change brings a number of benefits:The new data structures ensure that each item in the array / sequence complies with the value range restrictions of the numeric type.The numeric values can be stored more efficiently in memory which avoid the overhead of Python objects for each item.The memory layout of both data structures allows to read and write all items of the array / sequence in a single operation which makes the conversion from and to Python significantly faster / more efficient.launchThelaunch_testingpackage caught up with thelaunchpackage redesign done in Bouncy Bolson.
The legacy Python API, already moved into thelaunch.legacysubmodule, has thus been deprecated and removed.Seelaunchexamplesanddocumentationfor reference on how to use its new API.Seedemos testsfor reference on how to use the newlaunch_testingAPI.rmwChanges since theCrystal Clemmysrelease:New API inrmw, a fini function forrmw_context_t:rmw_context_finiModification ofrmw, now passesrmw_context_ttormw_create_wait_set:rmw_create_wait_setNew APIs inrmwfor preallocating space for published and subscribed messages:rmw_init_publisher_allocationrmw_fini_publisher_allocationrmw_init_subscription_allocationrmw_fini_subscription_allocationrmw_serialized_message_sizeModification ofrmw, now passesrmw_publisher_allocation_torrmw_subscription_allocation_ttormw_publishandrmw_take, respectively.
Note that this argument can beNULLornullptr, which keeps existing Crystal behavior.rmw_publishrmw_takeType names returned byrmw_get_*_names_and_types*functions should have a fully-qualified namespace.
For example, instead ofrcl_interfaces/Parameterandrcl_interfaces/GetParameters, the returned type names should bercl_interface/msg/Parameterandrcl_interfaces/srv/GetParameters.actionsChanges torclcpp_action::Clientsignatures:The signature ofrclcpp_action::Client::async_send_goalhas changed.
Now users can optionally provide callback functions for thegoal responseand theresultusing the newSendGoalOptionsstruct.
The goal response callback is called when an action server accepts or rejects the goal and the result callback is called when the result for the goal is received.
Optional callbacks were also added torclcpp_action::Client::async_cancel_goalandrclcpp_action::Client::async_get_result.Changes to goal transition names:The names of goal state transitions have been refactored to reflect the design documention.
This affectsrcl_action,rclcpp_action, andrclpy.
Here is a list of the event name changes (Old name -> New name):GOAL_EVENT_CANCEL -> GOAL_EVENT_CANCEL_GOALGOAL_EVENT_SET_SUCCEEDED -> GOAL_EVENT_SUCCEEDGOAL_EVENT_SET_ABORTED -> GOAL_EVENT_ABORTGOAL_EVENT_SET_CANCELED -> GOAL_EVENT_CANCELEDChanges toCancelGoal.srv:Areturn_codefield was added to the response message of theCancelGoalservice.
This is to better communicate a reason for a failed service call.
See thepull requestand connected issue for details.rvizPlugins should use fully qualified type names otherwise a warning will be logged.
Forexample, use the typesensor_msgs/msg/Imageinstead ofsensor_msgs/Image.
SeePR introducing this changefor more details.Known Issues[ros2/rclcpp#715]There is an inconsistency in the way that parameter YAML files are loaded between standalone ROS 2 nodes and composed ROS 2 nodes.
Currently available workarounds are noted in anissue comment[ros2/rclpy#360]rclpy nodes ignorectrl-cwhen using OpenSplice on Windows.[ros2/rosidl_typesupport_opensplice#30]There is a bug preventing nesting a message inside of a service or action definition with the same name when using OpenSplice.[ros2/rclcpp#781]Callingget_parameter/list_parameterfrom withinon_set_parameter_callbackcauses a deadlock on Dashing.  This is fixed for Eloquent, but is an ABI break so has not been backported to Dashing.[ros2/rclcpp#912]Inter-process communication forces a message copy when intra-process communication takes place between anstd::unique_ptrpublisher and a singlestd::unique_ptrsubscription (publishedstd::unique_ptris internally being promoted to anstd::shared_ptr).[ros2/rosbag2#125]Topics with unreliable QOS are not recorded.[ros2/rclcpp#715]Composable nodes cannot receive parameters via remapping. Supplying parameters to composable nodes can be accomplished using the methods described in[this comment].[ros2/rclcpp#893]rclcpp::Contextis not destroyed because of a reference cycle withrclcpp::GraphListener. This causes a memory leak. A fix has not been backported because of the risk of breaking ABI.Timeline before the releaseA few milestones leading up to the release:Mon. Apr 8th (alpha)First releases of core packages available.
Testing can happen from now on (some features might not have landed yet).Thu. May 2ndAPI freeze for core packagesMon. May 6th (beta)Updated releases of core packages available.
Additional testing of the latest features.Thu. May 16thFeature freeze.
Only bug fix releases should be made after this point.
New packages can be released independently.Mon. May 20th (release candidate)Updated releases of core packages available.Wed. May 29thFreeze rosdistro.
No PRs for Dashing on therosdistrorepo will be merged (reopens after the release announcement).

Code Examples:

Language: unknown
ament_index_has_resource(var...)if(${var})

Language: unknown
if(var)

Language: unknown
autocontext=rclcpp::contexts::default_context::get_global_default_context();std::vector<std::string>args;std::vector<rclcpp::Parameter>params={rclcpp::Parameter("use_sim_time",true)};autonode=std::make_shared<rclcpp::Node>("foo_node","bar_namespace",context,args,params);

Language: unknown
std::vector<std::string>args;std::vector<rclcpp::Parameter>params={rclcpp::Parameter("use_sim_time",true)};rclcpp::NodeOptionsnode_options;node_options.arguments(args);node_options.parameter_overrides(params);autonode=std::make_shared<rclcpp::Node>("foo_node","bar_namespace",node_options);

Language: unknown
template<typenameMessageT,typenameAllocatorT=std::allocator<void>,typenamePublisherT=::rclcpp::Publisher<MessageT,AllocatorT>>std::shared_ptr<PublisherT>create_publisher(conststd::string&topic_name,constrclcpp::QoS&qos,constPublisherOptionsWithAllocator<AllocatorT>&options=PublisherOptionsWithAllocator<AllocatorT>());template<typenameMessageT,typenameCallbackT,typenameAllocatorT=std::allocator<void>,typenameSubscriptionT=rclcpp::Subscription<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,AllocatorT>>std::shared_ptr<SubscriptionT>create_subscription(conststd::string&topic_name,constrclcpp::QoS&qos,CallbackT&&callback,constSubscriptionOptionsWithAllocator<AllocatorT>&options=SubscriptionOptionsWithAllocator<AllocatorT>(),typenamerclcpp::message_memory_strategy::MessageMemoryStrategy<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,AllocatorT>::SharedPtrmsg_mem_strat=nullptr);

Language: unknown
template<typenameMessageT,typenameAllocatorT=std::allocator<void>,typenamePublisherT=::rclcpp::Publisher<MessageT,AllocatorT>>[[deprecated("use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead")]]std::shared_ptr<PublisherT>create_publisher(conststd::string&topic_name,size_tqos_history_depth,std::shared_ptr<AllocatorT>allocator);template<typenameMessageT,typenameAllocatorT=std::allocator<void>,typenamePublisherT=::rclcpp::Publisher<MessageT,AllocatorT>>[[deprecated("use create_publisher(const std::string &, const rclcpp::QoS &, ...) instead")]]std::shared_ptr<PublisherT>create_publisher(conststd::string&topic_name,constrmw_qos_profile_t&qos_profile=rmw_qos_profile_default,std::shared_ptr<AllocatorT>allocator=nullptr);template<typenameMessageT,typenameCallbackT,typenameAlloc=std::allocator<void>,typenameSubscriptionT=rclcpp::Subscription<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>>[[deprecated("use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead")]]std::shared_ptr<SubscriptionT>create_subscription(conststd::string&topic_name,CallbackT&&callback,constrmw_qos_profile_t&qos_profile=rmw_qos_profile_default,rclcpp::callback_group::CallbackGroup::SharedPtrgroup=nullptr,boolignore_local_publications=false,typenamerclcpp::message_memory_strategy::MessageMemoryStrategy<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>::SharedPtrmsg_mem_strat=nullptr,std::shared_ptr<Alloc>allocator=nullptr);template<typenameMessageT,typenameCallbackT,typenameAlloc=std::allocator<void>,typenameSubscriptionT=rclcpp::Subscription<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>>[[deprecated("use create_subscription(const std::string &, const rclcpp::QoS &, CallbackT, ...) instead")]]std::shared_ptr<SubscriptionT>create_subscription(conststd::string&topic_name,CallbackT&&callback,size_tqos_history_depth,rclcpp::callback_group::CallbackGroup::SharedPtrgroup=nullptr,boolignore_local_publications=false,typenamerclcpp::message_memory_strategy::MessageMemoryStrategy<typenamerclcpp::subscription_traits::has_message_type<CallbackT>::type,Alloc>::SharedPtrmsg_mem_strat=nullptr,std::shared_ptr<Alloc>allocator=nullptr);

Language: unknown
- pub_ = create_publisher<std_msgs::msg::String>("chatter");+ pub_ = create_publisher<std_msgs::msg::String>("chatter", 10);

Language: unknown
- sub_ = create_subscription<std_msgs::msg::String>("chatter", callback);+ sub_ = create_subscription<std_msgs::msg::String>("chatter", 10, callback);

Language: unknown
- // Creates a latched topic- rmw_qos_profile_t qos = rmw_qos_profile_default;- qos.depth = 1;- qos.durability = RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL;-model_xml_.data = model_xml;node_handle->declare_parameter("robot_description", model_xml);description_pub_ = node_handle->create_publisher<std_msgs::msg::String>(-   "robot_description", qos);+   "robot_description",+   // Transient local is similar to latching in ROS 1.+   rclcpp::QoS(1).transient_local());

Language: unknown
constrclcpp::ParameterValue&rclcpp::Node::declare_parameter(conststd::string&name,constrclcpp::ParameterValue&default_value=rclcpp::ParameterValue(),constrcl_interfaces::msg::ParameterDescriptor&parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor());template<typenameParameterT>autorclcpp::Node::declare_parameter(conststd::string&name,constParameterT&default_value,constrcl_interfaces::msg::ParameterDescriptor&parameter_descriptor=rcl_interfaces::msg::ParameterDescriptor());template<typenameParameterT>std::vector<ParameterT>rclcpp::Node::declare_parameters(conststd::string&namespace_,conststd::map<std::string,ParameterT>&parameters);template<typenameParameterT>std::vector<ParameterT>rclcpp::Node::declare_parameters(conststd::string&namespace_,conststd::map<std::string,std::pair<ParameterT,rcl_interfaces::msg::ParameterDescriptor>>&parameters);

Language: unknown
voidrclcpp::Node::undeclare_parameter(conststd::string&name);boolrclcpp::Node::has_parameter(conststd::string&name)const;

Language: unknown
rcl_interfaces::msg::SetParametersResultrclcpp::Node::set_parameter(constrclcpp::Parameter&parameter);std::vector<rclcpp::Parameter>rclcpp::Node::get_parameters(conststd::vector<std::string>&names)const;rcl_interfaces::msg::ParameterDescriptorrclcpp::Node::describe_parameter(conststd::string&name)const;

Language: unknown
usingOnParametersSetCallbackType=rclcpp::node_interfaces::NodeParametersInterface::OnParametersSetCallbackType;OnParametersSetCallbackTyperclcpp::Node::set_on_parameters_set_callback(OnParametersSetCallbackTypecallback);

Language: unknown
template<typenameParameterT>[[deprecated("use declare_parameter() instead")]]voidrclcpp::Node::set_parameter_if_not_set(conststd::string&name,constParameterT&value);template<typenameParameterT>[[deprecated("use declare_parameters() instead")]]voidrclcpp::Node::set_parameters_if_not_set(conststd::string&name,conststd::map<std::string,ParameterT>&values);template<typenameParameterT>[[deprecated("use declare_parameter() and it's return value instead")]]voidrclcpp::Node::get_parameter_or_set(conststd::string&name,ParameterT&value,constParameterT&alternative_value);template<typenameCallbackT>[[deprecated("use set_on_parameters_set_callback() instead")]]voidrclcpp::Node::register_param_change_callback(CallbackT&&callback);

Language: unknown
classListener:publicrclcpp::Node{Listener(constrclcpp::NodeOptions&options):Node("listener",options){}};

Language: unknown
// Insert at bottom of translation unit, e.g. listener.cpp#include"rclcpp_components/register_node_macro.hpp"// Use fully-qualifed name in registrationRCLCPP_COMPONENTS_REGISTER_NODE(composition::Listener);

Language: unknown
add_library(listenersrc/listener.cpp)rclcpp_components_register_nodes(listener"composition::Listener")

Language: unknown
node.create_publisher(Empty,'chatter')# Or using a keyword argument for QoSProfilenode.create_publisher(Empty,'chatter',qos_profile=qos_profile_sensor_data)

Language: unknown
# Assume a history setting of KEEP_LAST with depth 10node.create_publisher(Empty,'chatter',10)# Or pass a QoSProfile object directlynode.create_publisher(Empty,'chatter',qos_profile_sensor_data)

Language: unknown
node.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg))# Or using a keyword argument for QoSProfilenode.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg),qos_profile=qos_profile_sensor_data)

Language: unknown
# Assume a history setting of KEEP_LAST with depth 10node.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg),10)# Or pass a QoSProfile object directlynode.create_subscription(BasicTypes,'chatter',lambdamsg:print(msg),qos_profile_sensor_data)

Language: unknown
QoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_ALL)QoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST,depth=10)QoSProfile(depth=10)# equivalent to the previous line

Language: unknown
QoSProfile()QoSProfile(reliability=QoSReliabilityPolicy.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT)# KEEP_LAST but no depthQoSProfile(history=QoSHistoryPolicy.RMW_QOS_POLICY_HISTORY_KEEP_LAST)

Language: unknown
defdeclare_parameter(name:str,value:Any=None,descriptor:ParameterDescriptor=ParameterDescriptor())->Parameterdefdeclare_parameters(namespace:str,parameters:List[Union[Tuple[str],Tuple[str,Any],Tuple[str,Any,ParameterDescriptor],]])->List[Parameter]

Language: unknown
defundeclare_parameter(name:str)->Nonedefhas_parameter(name:str)->bool

Language: unknown
defdescribe_parameter(name:str)->ParameterDescriptordefdescribe_parameters(names:List[str])->List[ParameterDescriptor]defset_descriptor(name:str,descriptor:ParameterDescriptor,alternative_value:Optional[ParameterValue]=None)->ParameterValue

Language: unknown
defget_parameter_or(name:str,alternative_value:Optional[Parameter]=None)->Parameter

Language: unknown
p=Parameter('myparam',Parameter.Type.DOUBLE,2.41)

Language: unknown
p=Parameter('myparam',value=2.41)
