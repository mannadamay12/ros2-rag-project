Title: Setting up a robot simulation (Basic)
URL: https://docs.ros.org/en/jazzy/Tutorials/Advanced/Simulators/Webots/Setting-Up-Simulation-Webots-Basic.html
Section: Installation
--------------------------------------------------------------------------------

Setting up a robot simulation (Basic)Goal:Setup a robot simulation and control it from ROS 2.Tutorial level:AdvancedTime:30 minutesContentsBackgroundPrerequisitesTasks1 Create the package structure2 Setup the simulation world3 Edit themy_robot_driverplugin4 Create themy_robot.urdffile5 Create the launch file6 Edit additional files7 Test the codeSummaryNext stepsBackgroundIn this tutorial, you are going to use the Webots robot simulator to set-up and run a very simple ROS 2 simulation scenario.Thewebots_ros2package provides an interface between ROS 2 and Webots.
It includes several sub-packages, but in this tutorial, you are going to use only thewebots_ros2_driversub-package to implement a Python or C++ plugin controlling a simulated robot.
Some other sub-packages contain demos with different robots such as the TurtleBot3.
They are documented in theWebots ROS 2 examplespage.PrerequisitesIt is recommended to understand basic ROS principles covered in the beginnerTutorials.
In particular,Using turtlesim, ros2, and rqt,Understanding topics,Creating a workspace,Creating a packageandCreating a launch fileare useful prerequisites.LinuxWindowsmacOSThe Linux and ROS commands of this tutorial can be run in a standard Linux terminal.
The following pageInstallation (Ubuntu)explains how to install thewebots_ros2package on Linux.The Linux and ROS commands of this tutorial must be run in a WSL (Windows Subsystem for Linux) environment.
The following pageInstallation (Windows)explains how to install thewebots_ros2package on Windows.The Linux and ROS commands of this tutorial must be run in a pre-configured Linux Virtual Machine (VM).
The following pageInstallation (macOS)explains how to install thewebots_ros2package on macOS.This tutorial is compatible with version 2023.1.0 ofwebots_ros2and Webots R2023b, as well as upcoming versions.Tasks1 Create the package structureLet’s organize the code in a custom ROS 2 package.
Create a new package namedmy_packagefrom thesrcfolder of your ROS 2 workspace.
Change the current directory of your terminal toros2_ws/srcand run:PythonC++ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name my_robot_driver my_package --dependencies rclpy geometry_msgs webots_ros2_driverThe--node-namemy_robot_driveroption will create amy_robot_driver.pytemplate Python plugin in themy_packagesubfolder that you will modify later.
The--dependenciesrclpygeometry_msgswebots_ros2_driveroption specifies the packages needed by themy_robot_driver.pyplugin in thepackage.xmlfile.Let’s add alaunchand aworldsfolder inside themy_packagefolder.cd my_packagemkdir launchmkdir worldsYou should end up with the following folder structure:src/└── my_package/├── launch/├── my_package/│   ├── __init__.py│   └── my_robot_driver.py├── resource/│   └── my_package├── test/│   ├── test_copyright.py│   ├── test_flake8.py│   └── test_pep257.py├── worlds/├── package.xml├── setup.cfg└── setup.pyros2 pkg create --build-type ament_cmake --license Apache-2.0 --node-name MyRobotDriver my_package --dependencies rclcpp geometry_msgs webots_ros2_driver pluginlibThe--node-nameMyRobotDriveroption will create aMyRobotDriver.cpptemplate C++ plugin in themy_package/srcsubfolder that you will modify later.
The--dependenciesrclcppgeometry_msgswebots_ros2_driverpluginliboption specifies the packages needed by theMyRobotDriverplugin in thepackage.xmlfile.Let’s add alaunch, aworldsand aresourcefolder inside themy_packagefolder.cd my_packagemkdir launchmkdir worldsmkdir resourceTwo additional files must be created: the header file forMyRobotDriverand themy_robot_driver.xmlpluginlib description file.touch my_robot_driver.xmltouch include/my_package/MyRobotDriver.hppYou should end up with the following folder structure:src/└── my_package/├── include/│   └── my_package/│       └── MyRobotDriver.hpp├── launch/├── resource/├── src/│   └── MyRobotDriver.cpp├── worlds/├── CMakeList.txt├── my_robot_driver.xml└── package.xml2 Setup the simulation worldYou will need a world file containing a robot to launch your simulation.Downloadthisworldfileand move it insidemy_package/worlds/.This is actually a fairly simple text file you can visualize in a text editor.
A simple robot is already included in thismy_world.wbtworld file.NoteIn case you want to learn how to create your own robot model in Webots, you can check thistutorial.3 Edit themy_robot_driverpluginThewebots_ros2_driversub-package automatically creates a ROS 2 interface for most sensors.
More details on existing device interfaces and how to configure them is given in the second part of the tutorial:Setting up a robot simulation (Advanced).
In this task, you will extend this interface by creating your own custom plugin.
This custom plugin is a ROS node equivalent to a robot controller.
You can use it to access theWebots robot APIand create your own topics and services to control your robot.NoteThe purpose of this tutorial is to show a basic example with a minimum number of dependencies.
However, you could avoid the use of this plugin by using anotherwebots_ros2sub-package namedwebots_ros2_control, introducing a new dependency.
This other sub-package creates an interface with theros2_controlpackage that facilitates the control of a differential wheeled robot.PythonC++Openmy_package/my_package/my_robot_driver.pyin your favorite editor and replace its contents with the following:importrclpyfromgeometry_msgs.msgimportTwistHALF_DISTANCE_BETWEEN_WHEELS=0.045WHEEL_RADIUS=0.025classMyRobotDriver:definit(self,webots_node,properties):self.__robot=webots_node.robotself.__left_motor=self.__robot.getDevice('left wheel motor')self.__right_motor=self.__robot.getDevice('right wheel motor')self.__left_motor.setPosition(float('inf'))self.__left_motor.setVelocity(0)self.__right_motor.setPosition(float('inf'))self.__right_motor.setVelocity(0)self.__target_twist=Twist()rclpy.init(args=None)self.__node=rclpy.create_node('my_robot_driver')self.__node.create_subscription(Twist,'cmd_vel',self.__cmd_vel_callback,1)def__cmd_vel_callback(self,twist):self.__target_twist=twistdefstep(self):rclpy.spin_once(self.__node,timeout_sec=0)forward_speed=self.__target_twist.linear.xangular_speed=self.__target_twist.angular.zcommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUScommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUSself.__left_motor.setVelocity(command_motor_left)self.__right_motor.setVelocity(command_motor_right)As you can see, theMyRobotDriverclass implements three methods.The first method, namedinit(self,...), is actually the ROS node counterpart of the Python__init__(self,...)constructor.
Theinitmethod always takes two arguments:Thewebots_nodeargument contains a reference on the Webots instance.Thepropertiesargument is a dictionary created from the XML tags given in the URDF files (4 Create the my_robot.urdf file) and allows you to pass parameters to the controller.The robot instance from the simulationself.__robotcan be used to access theWebots robot API.
Then, it gets the two motor instances and initializes them with a target position and a target velocity.
Finally a ROS node is created and a callback method is registered for a ROS topic named/cmd_velthat will handleTwistmessages.definit(self,webots_node,properties):self.__robot=webots_node.robotself.__left_motor=self.__robot.getDevice('left wheel motor')self.__right_motor=self.__robot.getDevice('right wheel motor')self.__left_motor.setPosition(float('inf'))self.__left_motor.setVelocity(0)self.__right_motor.setPosition(float('inf'))self.__right_motor.setVelocity(0)self.__target_twist=Twist()rclpy.init(args=None)self.__node=rclpy.create_node('my_robot_driver')self.__node.create_subscription(Twist,'cmd_vel',self.__cmd_vel_callback,1)Then comes the implementation of the__cmd_vel_callback(self,twist)callback private method that will be called for eachTwistmessage received on the/cmd_veltopic and will save it in theself.__target_twistmember variable.def__cmd_vel_callback(self,twist):self.__target_twist=twistFinally, thestep(self)method is called at every time step of the simulation.
The call torclpy.spin_once()is needed to keep the ROS node running smoothly.
At each time step, the method will retrieve the desiredforward_speedandangular_speedfromself.__target_twist.
As the motors are controlled with angular velocities, the method will then convert theforward_speedandangular_speedinto individual commands for each wheel.
This conversion depends on the structure of the robot, more specifically on the radius of the wheel and the distance between them.defstep(self):rclpy.spin_once(self.__node,timeout_sec=0)forward_speed=self.__target_twist.linear.xangular_speed=self.__target_twist.angular.zcommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUScommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUSself.__left_motor.setVelocity(command_motor_left)self.__right_motor.setVelocity(command_motor_right)Openmy_package/include/my_package/MyRobotDriver.hppin your favorite editor and replace its contents with the following:#ifndef WEBOTS_ROS2_PLUGIN_EXAMPLE_HPP#define WEBOTS_ROS2_PLUGIN_EXAMPLE_HPP#include"rclcpp/macros.hpp"#include"webots_ros2_driver/PluginInterface.hpp"#include"webots_ros2_driver/WebotsNode.hpp"#include"geometry_msgs/msg/twist.hpp"#include"rclcpp/rclcpp.hpp"namespacemy_robot_driver{classMyRobotDriver:publicwebots_ros2_driver::PluginInterface{public:voidstep()override;voidinit(webots_ros2_driver::WebotsNode*node,std::unordered_map<std::string,std::string>&parameters)override;private:rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtrcmd_vel_subscription_;geometry_msgs::msg::Twistcmd_vel_msg;WbDeviceTagright_motor;WbDeviceTagleft_motor;};}// namespace my_robot_driver#endifThe classMyRobotDriveris defined, which inherits from thewebots_ros2_driver::PluginInterfaceclass.
The plugin has to overridestep(...)andinit(...)functions.
More details are given in theMyRobotDriver.cppfile.
Several helper methods, callbacks and member variables that will be used internally by the plugin are declared privately.Then, openmy_package/src/MyRobotDriver.cppin your favorite editor and replace its contents with the following:#include"my_package/MyRobotDriver.hpp"#include"rclcpp/rclcpp.hpp"#include<cstdio>#include<functional>#include<webots/motor.h>#include<webots/robot.h>#define HALF_DISTANCE_BETWEEN_WHEELS 0.045#define WHEEL_RADIUS 0.025namespacemy_robot_driver{voidMyRobotDriver::init(webots_ros2_driver::WebotsNode*node,std::unordered_map<std::string,std::string>&parameters){right_motor=wb_robot_get_device("right wheel motor");left_motor=wb_robot_get_device("left wheel motor");wb_motor_set_position(left_motor,INFINITY);wb_motor_set_velocity(left_motor,0.0);wb_motor_set_position(right_motor,INFINITY);wb_motor_set_velocity(right_motor,0.0);cmd_vel_subscription_=node->create_subscription<geometry_msgs::msg::Twist>("/cmd_vel",rclcpp::SensorDataQoS().reliable(),[this](constgeometry_msgs::msg::Twist::SharedPtrmsg){this->cmd_vel_msg.linear=msg->linear;this->cmd_vel_msg.angular=msg->angular;});}voidMyRobotDriver::step(){autoforward_speed=cmd_vel_msg.linear.x;autoangular_speed=cmd_vel_msg.angular.z;autocommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;autocommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;wb_motor_set_velocity(left_motor,command_motor_left);wb_motor_set_velocity(right_motor,command_motor_right);}}// namespace my_robot_driver#include"pluginlib/class_list_macros.hpp"PLUGINLIB_EXPORT_CLASS(my_robot_driver::MyRobotDriver,webots_ros2_driver::PluginInterface)TheMyRobotDriver::initmethod is executed once the plugin is loaded by thewebots_ros2_driverpackage.
It takes two arguments:A pointer to theWebotsNodedefined bywebots_ros2_driver, which allows to access the ROS 2 node functions.Theparametersargument is an unordered map of strings, created from the XML tags given in the URDF files (4 Create the my_robot.urdf file) and allows to pass parameters to the controller. It is not used in this example.It initializes the plugin by setting up the robot motors, setting their positions and velocities, and subscribing to the/cmd_veltopic.voidMyRobotDriver::init(webots_ros2_driver::WebotsNode*node,std::unordered_map<std::string,std::string>&parameters){right_motor=wb_robot_get_device("right wheel motor");left_motor=wb_robot_get_device("left wheel motor");wb_motor_set_position(left_motor,INFINITY);wb_motor_set_velocity(left_motor,0.0);wb_motor_set_position(right_motor,INFINITY);wb_motor_set_velocity(right_motor,0.0);cmd_vel_subscription_=node->create_subscription<geometry_msgs::msg::Twist>("/cmd_vel",rclcpp::SensorDataQoS().reliable(),[this](constgeometry_msgs::msg::Twist::SharedPtrmsg){this->cmd_vel_msg.linear=msg->linear;this->cmd_vel_msg.angular=msg->angular;});}The subscription callback is declared as a lambda function, that will be called for each Twist message received on the/cmd_veltopic and will save it in thecmd_vel_msgmember variable.[this](constgeometry_msgs::msg::Twist::SharedPtrmsg){this->cmd_vel_msg.linear=msg->linear;this->cmd_vel_msg.angular=msg->angular;}Thestep()method is called at every time step of the simulation.
At each time step, the method will retrieve the desiredforward_speedandangular_speedfromcmd_vel_msg.
As the motors are controlled with angular velocities, the method will then convert theforward_speedandangular_speedinto individual commands for each wheel.
This conversion depends on the structure of the robot, more specifically on the radius of the wheel and the distance between them.voidMyRobotDriver::step(){autoforward_speed=cmd_vel_msg.linear.x;autoangular_speed=cmd_vel_msg.angular.z;autocommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;autocommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;wb_motor_set_velocity(left_motor,command_motor_left);wb_motor_set_velocity(right_motor,command_motor_right);}The final lines of the file define the end of themy_robot_drivernamespace and include a macro to export theMyRobotDriverclass as a plugin using thePLUGINLIB_EXPORT_CLASSmacro.
This allows the plugin to be loaded by the Webots ROS2 driver at runtime.#include"pluginlib/class_list_macros.hpp"PLUGINLIB_EXPORT_CLASS(my_robot_driver::MyRobotDriver,webots_ros2_driver::PluginInterface)NoteWhile the plugin is implemented in C++, the C API must be used to interact with the Webots controller library.4 Create themy_robot.urdffileYou now have to create a URDF file to declare theMyRobotDriverplugin.
This will allow thewebots_ros2_driverROS node to launch the plugin and connect it to the target robot.In themy_package/resourcefolder create a text file namedmy_robot.urdfwith this content:PythonC++<?xml version="1.0" ?><robotname="My robot"><webots><plugintype="my_package.my_robot_driver.MyRobotDriver"/></webots></robot>Thetypeattribute specifies the path to the class given by the hierarchical structure of files.webots_ros2_driveris responsible for loading the class based on the specified package and modules.<?xml version="1.0" ?><robotname="My robot"><webots><plugintype="my_robot_driver::MyRobotDriver"/></webots></robot>Thetypeattribute specifies the namespace and class name to load.pluginlibis responsible for loading the class based on the specified information.NoteThis simple URDF file doesn’t contain any link or joint information about the robot as it is not needed in this tutorial.
However, URDF files usually contain much more information as explained in theURDFtutorial.NoteHere the plugin does not take any input parameter, but this can be achieved with a tag containing the parameter name.PythonC++<plugintype="my_package.my_robot_driver.MyRobotDriver"><parameterName>someValue</parameterName></plugin><plugintype="my_robot_driver::MyRobotDriver"><parameterName>someValue</parameterName></plugin>This is namely used to pass parameters to existing Webots device plugins (seeSetting up a robot simulation (Advanced)).5 Create the launch fileLet’s create the launch file to easily launch the simulation and the ROS controller with a single command.
In themy_package/launchfolder create a new text file namedrobot_launch.pywith this code:importosimportlaunchfromlaunchimportLaunchDescriptionfromament_index_python.packagesimportget_package_share_directoryfromwebots_ros2_driver.webots_launcherimportWebotsLauncherfromwebots_ros2_driver.webots_controllerimportWebotsControllerdefgenerate_launch_description():package_dir=get_package_share_directory('my_package')robot_description_path=os.path.join(package_dir,'resource','my_robot.urdf')webots=WebotsLauncher(world=os.path.join(package_dir,'worlds','my_world.wbt'))my_robot_driver=WebotsController(robot_name='my_robot',parameters=[{'robot_description':robot_description_path},])returnLaunchDescription([webots,my_robot_driver,launch.actions.RegisterEventHandler(event_handler=launch.event_handlers.OnProcessExit(target_action=webots,on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],))])TheWebotsLauncherobject is a custom action that allows you to start a Webots simulation instance.
You have to specify in the constructor which world file the simulator will open.webots=WebotsLauncher(world=os.path.join(package_dir,'worlds','my_world.wbt'))Then, the ROS node interacting with the simulated robot is created.
This node, namedWebotsController, is located in thewebots_ros2_driverpackage.LinuxWindowsmacOSThe node will be able to communicate with the simulated robot by using a custom protocol based on IPC and shared memory.The node (in WSL) will be able to communicate with the simulated robot (in Webots on native Windows) through a TCP connection.The node (in the docker container) will be able to communicate with the simulated robot (in Webots on native macOS) through a TCP connection.In your case, you need to run a single instance of this node, because you have a single robot in the simulation.
But if you had more robots in the simulation, you would have to run one instance of this node per robot.
Therobot_nameparameter is used to define the name of the robot the driver should connect to.
Therobot_descriptionparameter holds the path to the URDF file which refers to theMyRobotDriverplugin.
You can see theWebotsControllernode as the interface that connects your controller plugin to the target robot.my_robot_driver=WebotsController(robot_name='my_robot',parameters=[{'robot_description':robot_description_path},])After that, the two nodes are set to be launched in theLaunchDescriptionconstructor:returnLaunchDescription([webots,my_robot_driver,Finally, an optional part is added in order to shutdown all the nodes once Webots terminates (e.g., when it gets closed from the graphical user interface).launch.actions.RegisterEventHandler(event_handler=launch.event_handlers.OnProcessExit(target_action=webots,on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],))NoteMore details onWebotsControllerandWebotsLauncherarguments can be foundon the nodes reference page.6 Edit additional filesPythonC++Before you can start the launch file, you have to modify thesetup.pyfile to include the extra files you added.
Openmy_package/setup.pyand replace its contents with:fromsetuptoolsimportfind_packages,setuppackage_name='my_package'data_files=[]data_files.append(('share/ament_index/resource_index/packages',['resource/'+package_name]))data_files.append(('share/'+package_name+'/launch',['launch/robot_launch.py']))data_files.append(('share/'+package_name+'/worlds',['worlds/my_world.wbt']))data_files.append(('share/'+package_name+'/resource',['resource/my_robot.urdf']))data_files.append(('share/'+package_name,['package.xml']))setup(name=package_name,version='0.0.0',packages=find_packages(exclude=['test']),data_files=data_files,install_requires=['setuptools'],zip_safe=True,maintainer='user',maintainer_email='user.name@mail.com',description='TODO: Package description',license='TODO: License declaration',tests_require=['pytest'],entry_points={'console_scripts':['my_robot_driver = my_package.my_robot_driver:main',],},)This sets-up the package and adds in thedata_filesvariable the newly added files:my_world.wbt,my_robot.urdfandrobot_launch.py.Before you can start the launch file, you have to modifyCMakeLists.txtandmy_robot_driver.xmlfiles:CMakeLists.txtdefines the compilation rules of your plugin.my_robot_driver.xmlis necessary for the pluginlib to find your Webots ROS 2 plugin.Openmy_package/my_robot_driver.xmland replace its contents with:<librarypath="my_package"><!-- The `type` attribute is a reference to the plugin class. --><!-- The `base_class_type` attribute is always `webots_ros2_driver::PluginInterface`. --><classtype="my_robot_driver::MyRobotDriver"base_class_type="webots_ros2_driver::PluginInterface"><description>ThisisaWebotsROS2pluginexample</description></class></library>Openmy_package/CMakeLists.txtand replace its contents with:cmake_minimum_required(VERSION3.5)project(my_package)if(NOTCMAKE_CXX_STANDARD)set(CMAKE_CXX_STANDARD14)endif()# Besides the package specific dependencies we also need the `pluginlib` and `webots_ros2_driver`find_package(ament_cmakeREQUIRED)find_package(rclcppREQUIRED)find_package(std_msgsREQUIRED)find_package(geometry_msgsREQUIRED)find_package(pluginlibREQUIRED)find_package(webots_ros2_driverREQUIRED)# Export the plugin configuration filepluginlib_export_plugin_description_file(webots_ros2_drivermy_robot_driver.xml)# MyRobotDriver libraryadd_library(${PROJECT_NAME}SHAREDsrc/MyRobotDriver.cpp)target_include_directories(${PROJECT_NAME}PRIVATEinclude)ament_target_dependencies(${PROJECT_NAME}pluginlibrclcppwebots_ros2_driver)install(TARGETS${PROJECT_NAME}ARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)# Install additional directories.install(DIRECTORYlaunchresourceworldsDESTINATIONshare/${PROJECT_NAME}/)ament_export_include_directories(include)ament_export_libraries(${PROJECT_NAME})ament_package()The CMakeLists.txt exports the plugin configuration file with thepluginlib_export_plugin_description_file(), defines a shared library of the C++ pluginsrc/MyRobotDriver.cpp, and sets the include and library dependencies usingament_target_dependencies().The file then installs the library, the directorieslaunch,resource, andworldsto theshare/my_packagedirectory.
Finally, it exports the include directories and libraries usingament_export_include_directories()andament_export_libraries(), respectively, and declares the package usingament_package().7 Test the codeLinuxWindowsmacOSFrom a terminal in your ROS 2 workspace run:colcon buildsource install/local_setup.bashros2 launch my_package robot_launch.pyThis will launch the simulation.
Webots will be automatically installed on the first run in case it was not already installed.From a terminal in your WSL ROS 2 workspace run:colcon buildexport WEBOTS_HOME=/mnt/c/Program\ Files/Webotssource install/local_setup.bashros2 launch my_package robot_launch.pyBe sure to use the/mntprefix in front of your path to the Webots installation folder to access the Windows file system from WSL.This will launch the simulation.
Webots will be automatically installed on the first run in case it was not already installed.On macOS, a local server must be started on the host to start Webots from the VM.
The local server can be downloadedon the webots-server repository.In a terminal of the host machine (not in the VM), specify the Webots installation folder (e.g./Applications/Webots.app) and start the server using the following commands:export WEBOTS_HOME=/Applications/Webots.apppython3 local_simulation_server.pyFrom a terminal in the Linux VM in your ROS 2 workspace, build and launch your custom package with:colcon buildsource install/local_setup.bashros2 launch my_package robot_launch.pyNoteIf you want to install Webots manually, you can download ithere.Then, open a second terminal and send a command with:ros2 topic pub /cmd_vel geometry_msgs/Twist  "linear: { x: 0.1 }"The robot is now moving forward.At this point, the robot is able to blindly follow your motor commands.
But it will eventually bump into the wall as you order it to move forwards.Close the Webots window, this should also shutdown your ROS nodes started from the launcher.
Close also the topic command withCtrl+Cin the second terminal.SummaryIn this tutorial, you set-up a realistic robot simulation with Webots and implemented a custom plugin to control the motors of the robot.Next stepsTo improve the simulation, the robot’s sensors can be used to detect obstacles and avoid them.
The second part of the tutorial shows how to implement such behaviour:Setting up a robot simulation (Advanced).

Code Examples:

Language: unknown
ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name my_robot_driver my_package --dependencies rclpy geometry_msgs webots_ros2_driver

Language: unknown
cd my_packagemkdir launchmkdir worlds

Language: unknown
src/└── my_package/├── launch/├── my_package/│   ├── __init__.py│   └── my_robot_driver.py├── resource/│   └── my_package├── test/│   ├── test_copyright.py│   ├── test_flake8.py│   └── test_pep257.py├── worlds/├── package.xml├── setup.cfg└── setup.py

Language: unknown
ros2 pkg create --build-type ament_cmake --license Apache-2.0 --node-name MyRobotDriver my_package --dependencies rclcpp geometry_msgs webots_ros2_driver pluginlib

Language: unknown
cd my_packagemkdir launchmkdir worldsmkdir resource

Language: unknown
touch my_robot_driver.xmltouch include/my_package/MyRobotDriver.hpp

Language: unknown
src/└── my_package/├── include/│   └── my_package/│       └── MyRobotDriver.hpp├── launch/├── resource/├── src/│   └── MyRobotDriver.cpp├── worlds/├── CMakeList.txt├── my_robot_driver.xml└── package.xml

Language: unknown
importrclpyfromgeometry_msgs.msgimportTwistHALF_DISTANCE_BETWEEN_WHEELS=0.045WHEEL_RADIUS=0.025classMyRobotDriver:definit(self,webots_node,properties):self.__robot=webots_node.robotself.__left_motor=self.__robot.getDevice('left wheel motor')self.__right_motor=self.__robot.getDevice('right wheel motor')self.__left_motor.setPosition(float('inf'))self.__left_motor.setVelocity(0)self.__right_motor.setPosition(float('inf'))self.__right_motor.setVelocity(0)self.__target_twist=Twist()rclpy.init(args=None)self.__node=rclpy.create_node('my_robot_driver')self.__node.create_subscription(Twist,'cmd_vel',self.__cmd_vel_callback,1)def__cmd_vel_callback(self,twist):self.__target_twist=twistdefstep(self):rclpy.spin_once(self.__node,timeout_sec=0)forward_speed=self.__target_twist.linear.xangular_speed=self.__target_twist.angular.zcommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUScommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUSself.__left_motor.setVelocity(command_motor_left)self.__right_motor.setVelocity(command_motor_right)

Language: unknown
definit(self,webots_node,properties):self.__robot=webots_node.robotself.__left_motor=self.__robot.getDevice('left wheel motor')self.__right_motor=self.__robot.getDevice('right wheel motor')self.__left_motor.setPosition(float('inf'))self.__left_motor.setVelocity(0)self.__right_motor.setPosition(float('inf'))self.__right_motor.setVelocity(0)self.__target_twist=Twist()rclpy.init(args=None)self.__node=rclpy.create_node('my_robot_driver')self.__node.create_subscription(Twist,'cmd_vel',self.__cmd_vel_callback,1)

Language: unknown
def__cmd_vel_callback(self,twist):self.__target_twist=twist

Language: unknown
defstep(self):rclpy.spin_once(self.__node,timeout_sec=0)forward_speed=self.__target_twist.linear.xangular_speed=self.__target_twist.angular.zcommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUScommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUSself.__left_motor.setVelocity(command_motor_left)self.__right_motor.setVelocity(command_motor_right)

Language: unknown
#ifndef WEBOTS_ROS2_PLUGIN_EXAMPLE_HPP#define WEBOTS_ROS2_PLUGIN_EXAMPLE_HPP#include"rclcpp/macros.hpp"#include"webots_ros2_driver/PluginInterface.hpp"#include"webots_ros2_driver/WebotsNode.hpp"#include"geometry_msgs/msg/twist.hpp"#include"rclcpp/rclcpp.hpp"namespacemy_robot_driver{classMyRobotDriver:publicwebots_ros2_driver::PluginInterface{public:voidstep()override;voidinit(webots_ros2_driver::WebotsNode*node,std::unordered_map<std::string,std::string>&parameters)override;private:rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtrcmd_vel_subscription_;geometry_msgs::msg::Twistcmd_vel_msg;WbDeviceTagright_motor;WbDeviceTagleft_motor;};}// namespace my_robot_driver#endif

Language: unknown
#include"my_package/MyRobotDriver.hpp"#include"rclcpp/rclcpp.hpp"#include<cstdio>#include<functional>#include<webots/motor.h>#include<webots/robot.h>#define HALF_DISTANCE_BETWEEN_WHEELS 0.045#define WHEEL_RADIUS 0.025namespacemy_robot_driver{voidMyRobotDriver::init(webots_ros2_driver::WebotsNode*node,std::unordered_map<std::string,std::string>&parameters){right_motor=wb_robot_get_device("right wheel motor");left_motor=wb_robot_get_device("left wheel motor");wb_motor_set_position(left_motor,INFINITY);wb_motor_set_velocity(left_motor,0.0);wb_motor_set_position(right_motor,INFINITY);wb_motor_set_velocity(right_motor,0.0);cmd_vel_subscription_=node->create_subscription<geometry_msgs::msg::Twist>("/cmd_vel",rclcpp::SensorDataQoS().reliable(),[this](constgeometry_msgs::msg::Twist::SharedPtrmsg){this->cmd_vel_msg.linear=msg->linear;this->cmd_vel_msg.angular=msg->angular;});}voidMyRobotDriver::step(){autoforward_speed=cmd_vel_msg.linear.x;autoangular_speed=cmd_vel_msg.angular.z;autocommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;autocommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;wb_motor_set_velocity(left_motor,command_motor_left);wb_motor_set_velocity(right_motor,command_motor_right);}}// namespace my_robot_driver#include"pluginlib/class_list_macros.hpp"PLUGINLIB_EXPORT_CLASS(my_robot_driver::MyRobotDriver,webots_ros2_driver::PluginInterface)

Language: unknown
voidMyRobotDriver::init(webots_ros2_driver::WebotsNode*node,std::unordered_map<std::string,std::string>&parameters){right_motor=wb_robot_get_device("right wheel motor");left_motor=wb_robot_get_device("left wheel motor");wb_motor_set_position(left_motor,INFINITY);wb_motor_set_velocity(left_motor,0.0);wb_motor_set_position(right_motor,INFINITY);wb_motor_set_velocity(right_motor,0.0);cmd_vel_subscription_=node->create_subscription<geometry_msgs::msg::Twist>("/cmd_vel",rclcpp::SensorDataQoS().reliable(),[this](constgeometry_msgs::msg::Twist::SharedPtrmsg){this->cmd_vel_msg.linear=msg->linear;this->cmd_vel_msg.angular=msg->angular;});}

Language: unknown
[this](constgeometry_msgs::msg::Twist::SharedPtrmsg){this->cmd_vel_msg.linear=msg->linear;this->cmd_vel_msg.angular=msg->angular;}

Language: unknown
voidMyRobotDriver::step(){autoforward_speed=cmd_vel_msg.linear.x;autoangular_speed=cmd_vel_msg.angular.z;autocommand_motor_left=(forward_speed-angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;autocommand_motor_right=(forward_speed+angular_speed*HALF_DISTANCE_BETWEEN_WHEELS)/WHEEL_RADIUS;wb_motor_set_velocity(left_motor,command_motor_left);wb_motor_set_velocity(right_motor,command_motor_right);}

Language: unknown
#include"pluginlib/class_list_macros.hpp"PLUGINLIB_EXPORT_CLASS(my_robot_driver::MyRobotDriver,webots_ros2_driver::PluginInterface)

Language: unknown
<?xml version="1.0" ?><robotname="My robot"><webots><plugintype="my_package.my_robot_driver.MyRobotDriver"/></webots></robot>

Language: unknown
<?xml version="1.0" ?><robotname="My robot"><webots><plugintype="my_robot_driver::MyRobotDriver"/></webots></robot>

Language: unknown
<plugintype="my_package.my_robot_driver.MyRobotDriver"><parameterName>someValue</parameterName></plugin>

Language: unknown
<plugintype="my_robot_driver::MyRobotDriver"><parameterName>someValue</parameterName></plugin>

Language: unknown
importosimportlaunchfromlaunchimportLaunchDescriptionfromament_index_python.packagesimportget_package_share_directoryfromwebots_ros2_driver.webots_launcherimportWebotsLauncherfromwebots_ros2_driver.webots_controllerimportWebotsControllerdefgenerate_launch_description():package_dir=get_package_share_directory('my_package')robot_description_path=os.path.join(package_dir,'resource','my_robot.urdf')webots=WebotsLauncher(world=os.path.join(package_dir,'worlds','my_world.wbt'))my_robot_driver=WebotsController(robot_name='my_robot',parameters=[{'robot_description':robot_description_path},])returnLaunchDescription([webots,my_robot_driver,launch.actions.RegisterEventHandler(event_handler=launch.event_handlers.OnProcessExit(target_action=webots,on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],))])

Language: unknown
webots=WebotsLauncher(world=os.path.join(package_dir,'worlds','my_world.wbt'))

Language: unknown
my_robot_driver=WebotsController(robot_name='my_robot',parameters=[{'robot_description':robot_description_path},])

Language: unknown
returnLaunchDescription([webots,my_robot_driver,

Language: unknown
launch.actions.RegisterEventHandler(event_handler=launch.event_handlers.OnProcessExit(target_action=webots,on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],))

Language: unknown
fromsetuptoolsimportfind_packages,setuppackage_name='my_package'data_files=[]data_files.append(('share/ament_index/resource_index/packages',['resource/'+package_name]))data_files.append(('share/'+package_name+'/launch',['launch/robot_launch.py']))data_files.append(('share/'+package_name+'/worlds',['worlds/my_world.wbt']))data_files.append(('share/'+package_name+'/resource',['resource/my_robot.urdf']))data_files.append(('share/'+package_name,['package.xml']))setup(name=package_name,version='0.0.0',packages=find_packages(exclude=['test']),data_files=data_files,install_requires=['setuptools'],zip_safe=True,maintainer='user',maintainer_email='user.name@mail.com',description='TODO: Package description',license='TODO: License declaration',tests_require=['pytest'],entry_points={'console_scripts':['my_robot_driver = my_package.my_robot_driver:main',],},)

Language: unknown
<librarypath="my_package"><!-- The `type` attribute is a reference to the plugin class. --><!-- The `base_class_type` attribute is always `webots_ros2_driver::PluginInterface`. --><classtype="my_robot_driver::MyRobotDriver"base_class_type="webots_ros2_driver::PluginInterface"><description>ThisisaWebotsROS2pluginexample</description></class></library>

Language: unknown
cmake_minimum_required(VERSION3.5)project(my_package)if(NOTCMAKE_CXX_STANDARD)set(CMAKE_CXX_STANDARD14)endif()# Besides the package specific dependencies we also need the `pluginlib` and `webots_ros2_driver`find_package(ament_cmakeREQUIRED)find_package(rclcppREQUIRED)find_package(std_msgsREQUIRED)find_package(geometry_msgsREQUIRED)find_package(pluginlibREQUIRED)find_package(webots_ros2_driverREQUIRED)# Export the plugin configuration filepluginlib_export_plugin_description_file(webots_ros2_drivermy_robot_driver.xml)# MyRobotDriver libraryadd_library(${PROJECT_NAME}SHAREDsrc/MyRobotDriver.cpp)target_include_directories(${PROJECT_NAME}PRIVATEinclude)ament_target_dependencies(${PROJECT_NAME}pluginlibrclcppwebots_ros2_driver)install(TARGETS${PROJECT_NAME}ARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)# Install additional directories.install(DIRECTORYlaunchresourceworldsDESTINATIONshare/${PROJECT_NAME}/)ament_export_include_directories(include)ament_export_libraries(${PROJECT_NAME})ament_package()

Language: unknown
colcon buildsource install/local_setup.bashros2 launch my_package robot_launch.py

Language: unknown
colcon buildexport WEBOTS_HOME=/mnt/c/Program\ Files/Webotssource install/local_setup.bashros2 launch my_package robot_launch.py

Language: unknown
export WEBOTS_HOME=/Applications/Webots.apppython3 local_simulation_server.py

Language: unknown
colcon buildsource install/local_setup.bashros2 launch my_package robot_launch.py

Language: unknown
ros2 topic pub /cmd_vel geometry_msgs/Twist  "linear: { x: 0.1 }"
