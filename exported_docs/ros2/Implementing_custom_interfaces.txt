Title: Implementing custom interfaces
URL: https://docs.ros.org/en/jazzy/Tutorials/Beginner-Client-Libraries/Single-Package-Define-And-Use-Interface.html
Section: Installation
--------------------------------------------------------------------------------

Implementing custom interfacesGoal:Learn more ways to implement custom interfaces in ROS 2.Tutorial level:BeginnerTime:15 minutesContentsBackgroundPrerequisitesTasks1 Create a package2 Create a msg file3 Use an interface from the same package4 Try it out5 (Extra) Use an existing interface definitionSummaryNext stepsRelated contentBackgroundIn aprevious tutorial, you learned how to create custom msg and srv interfaces.While best practice is to declare interfaces in dedicated interface packages, sometimes it can be convenient to declare, create and use an interface all in one package.Recall that interfaces can currently only be defined in CMake packages.
It is possible, however, to have Python libraries and nodes in CMake packages (usingament_cmake_python), so you could define interfaces and Python nodes together in one package.
We’ll use a CMake package and C++ nodes here for the sake of simplicity.This tutorial will focus on the msg interface type, but the steps here are applicable to all interface types.PrerequisitesWe assume you’ve reviewed the basics in theCreating custom msg and srv filestutorial before working through this one.You should haveROS 2 installed, aworkspace, and an understanding ofcreating packages.As always, don’t forget tosource ROS 2in every new terminal you open.Tasks1 Create a packageIn your workspacesrcdirectory, create a packagemore_interfacesand make a directory within it for msg files:ros2 pkg create --build-type ament_cmake --license Apache-2.0 more_interfacesmkdir more_interfaces/msg2 Create a msg fileInsidemore_interfaces/msg, create a new fileAddressBook.msg, and paste the following code to create a message meant to carry information about an individual:uint8PHONE_TYPE_HOME=0uint8PHONE_TYPE_WORK=1uint8PHONE_TYPE_MOBILE=2stringfirst_namestringlast_namestringphone_numberuint8phone_typeThis message is composed of these fields:first_name: of type stringlast_name: of type stringphone_number: of type stringphone_type: of type uint8, with several named constant values definedNote that it’s possible to set default values for fields within a message definition.
SeeInterfacesfor more ways you can customize interfaces.Next, we need to make sure that the msg file is turned into source code for C++, Python, and other languages.2.1 Build a msg fileOpenpackage.xmland add the following lines:<buildtool_depend>rosidl_default_generators</buildtool_depend><exec_depend>rosidl_default_runtime</exec_depend><member_of_group>rosidl_interface_packages</member_of_group>Note that at build time, we needrosidl_default_generators, while at runtime, we only needrosidl_default_runtime.OpenCMakeLists.txtand add the following lines:Find the package that generates message code from msg/srv files:find_package(rosidl_default_generatorsREQUIRED)Declare the list of messages you want to generate:set(msg_files"msg/AddressBook.msg")By adding the .msg files manually, we make sure that CMake knows when it has to reconfigure the project after you add other .msg files.Generate the messages:rosidl_generate_interfaces(${PROJECT_NAME}${msg_files})Also make sure you export the message runtime dependency:ament_export_dependencies(rosidl_default_runtime)Now you’re ready to generate source files from your msg definition.
We’ll skip the compile step for now as we’ll do it all together below in step 4.3 Use an interface from the same packageNow we can start writing code that uses this message.Inmore_interfaces/srccreate a file calledpublish_address_book.cppand paste the following code:#include<chrono>#include<memory>#include"rclcpp/rclcpp.hpp"#include"more_interfaces/msg/address_book.hpp"usingnamespacestd::chrono_literals;classAddressBookPublisher:publicrclcpp::Node{public:AddressBookPublisher():Node("address_book_publisher"){address_book_publisher_=this->create_publisher<more_interfaces::msg::AddressBook>("address_book",10);autopublish_msg=[this]()->void{automessage=more_interfaces::msg::AddressBook();message.first_name="John";message.last_name="Doe";message.phone_number="1234567890";message.phone_type=message.PHONE_TYPE_MOBILE;std::cout<<"Publishing Contact\nFirst:"<<message.first_name<<"  Last:"<<message.last_name<<std::endl;this->address_book_publisher_->publish(message);};timer_=this->create_wall_timer(1s,publish_msg);}private:rclcpp::Publisher<more_interfaces::msg::AddressBook>::SharedPtraddress_book_publisher_;rclcpp::TimerBase::SharedPtrtimer_;};intmain(intargc,char*argv[]){rclcpp::init(argc,argv);rclcpp::spin(std::make_shared<AddressBookPublisher>());rclcpp::shutdown();return0;}3.1 The code explainedInclude the header of our newly createdAddressBook.msg.#include"more_interfaces/msg/address_book.hpp"Create a node and anAddressBookpublisher.usingnamespacestd::chrono_literals;classAddressBookPublisher:publicrclcpp::Node{public:AddressBookPublisher():Node("address_book_publisher"){address_book_publisher_=this->create_publisher<more_interfaces::msg::AddressBook>("address_book");Create a callback to publish the messages periodically.autopublish_msg=[this]()->void{Create anAddressBookmessage instance that we will later publish.automessage=more_interfaces::msg::AddressBook();PopulateAddressBookfields.message.first_name="John";message.last_name="Doe";message.phone_number="1234567890";message.phone_type=message.PHONE_TYPE_MOBILE;Finally send the message periodically.std::cout<<"Publishing Contact\nFirst:"<<message.first_name<<"  Last:"<<message.last_name<<std::endl;this->address_book_publisher_->publish(message);Create a 1 second timer to call ourpublish_msgfunction every second.timer_=this->create_wall_timer(1s,publish_msg);3.2 Build the publisherWe need to create a new target for this node in theCMakeLists.txt:find_package(rclcppREQUIRED)add_executable(publish_address_booksrc/publish_address_book.cpp)ament_target_dependencies(publish_address_bookrclcpp)install(TARGETSpublish_address_bookDESTINATIONlib/${PROJECT_NAME})3.3 Link against the interfaceIn order to use the messages generated in the same package we need to use the following CMake code:rosidl_get_typesupport_target(cpp_typesupport_target${PROJECT_NAME}rosidl_typesupport_cpp)target_link_libraries(publish_address_book"${cpp_typesupport_target}")This finds the relevant generated C++ code fromAddressBook.msgand allows your target to link against it.You may have noticed that this step was not necessary when the interfaces being used were from a different package that was built independently.
This CMake code is only required when you want to use interfaces in the same package as the one in which they are defined.4 Try it outReturn to the root of the workspace to build the package:LinuxmacOSWindowscd ~/ros2_wscolcon build --packages-up-to more_interfacescd ~/ros2_wscolcon build --packages-up-to more_interfacescd /ros2_wscolcon build --merge-install --packages-up-to more_interfacesThen source the workspace and run the publisher:LinuxmacOSWindowssource install/local_setup.bashros2 run more_interfaces publish_address_book. install/local_setup.bashros2 run more_interfaces publish_address_bookcall install/local_setup.batros2 run more_interfaces publish_address_bookOr using Powershell:install/local_setup.ps1ros2 run more_interfaces publish_address_bookYou should see the publisher relaying the msg you defined, including the values you set inpublish_address_book.cpp.To confirm the message is being published on theaddress_booktopic, open another terminal, source the workspace, and calltopicecho:LinuxmacOSWindowssource install/setup.bashros2 topic echo /address_book. install/setup.bashros2 topic echo /address_bookcall install/setup.batros2 topic echo /address_bookOr using Powershell:install/setup.ps1ros2 topic echo /address_bookWe won’t create a subscriber in this tutorial, but you can try to write one yourself for practice (useWriting a simple publisher and subscriber (C++)to help).5 (Extra) Use an existing interface definitionNoteYou can use an existing interface definition in a new interface definition.
For example, let’s say there is a message namedContact.msgthat belongs to an existing ROS 2 package namedrosidl_tutorials_msgs.
Assume that its definition is identical to our custom-madeAddressBook.msginterface from earlier.In that case you could have definedAddressBook.msg(an interface in the packagewithyour nodes) as typeContact(an interface in aseparatepackage).
You could even defineAddressBook.msgas anarrayof typeContact, like so:rosidl_tutorials_msgs/Contact[]address_bookTo generate this message you would need to declare a dependency onContact.msg'spackage,rosidl_tutorials_msgs, inpackage.xml:<build_depend>rosidl_tutorials_msgs</build_depend><exec_depend>rosidl_tutorials_msgs</exec_depend>And inCMakeLists.txt:find_package(rosidl_tutorials_msgsREQUIRED)rosidl_generate_interfaces(${PROJECT_NAME}${msg_files}DEPENDENCIESrosidl_tutorials_msgs)You would also need to include the header ofContact.msgin your publisher node in order to be able to addcontactsto youraddress_book.#include"rosidl_tutorials_msgs/msg/contact.hpp"You could change the callback to something like this:autopublish_msg=[this]()->void{automsg=std::make_shared<more_interfaces::msg::AddressBook>();{rosidl_tutorials_msgs::msg::Contactcontact;contact.first_name="John";contact.last_name="Doe";contact.phone_number="1234567890";contact.phone_type=message.PHONE_TYPE_MOBILE;msg->address_book.push_back(contact);}{rosidl_tutorials_msgs::msg::Contactcontact;contact.first_name="Jane";contact.last_name="Doe";contact.phone_number="4254242424";contact.phone_type=message.PHONE_TYPE_HOME;msg->address_book.push_back(contact);}std::cout<<"Publishing address book:"<<std::endl;for(autocontact:msg->address_book){std::cout<<"First:"<<contact.first_name<<"  Last:"<<contact.last_name<<std::endl;}address_book_publisher_->publish(*msg);};Building and running these changes would show the msg defined as expected, as well as the array of msgs defined above.SummaryIn this tutorial, you tried out different field types for defining interfaces, then built an interface in the same package where it’s being used.You also learned how to use another interface as a field type, as well as thepackage.xml,CMakeLists.txt, and#includestatements necessary for utilizing that feature.Next stepsNext you will create a simple ROS 2 package with a custom parameter that you will learn to set from a launch file.
Again, you can choose to write it in eitherC++orPython.Related contentThere areseveral design articleson ROS 2 interfaces and the IDL (interface definition language).

Code Examples:

Language: unknown
ros2 pkg create --build-type ament_cmake --license Apache-2.0 more_interfacesmkdir more_interfaces/msg

Language: unknown
uint8PHONE_TYPE_HOME=0uint8PHONE_TYPE_WORK=1uint8PHONE_TYPE_MOBILE=2stringfirst_namestringlast_namestringphone_numberuint8phone_type

Language: unknown
<buildtool_depend>rosidl_default_generators</buildtool_depend><exec_depend>rosidl_default_runtime</exec_depend><member_of_group>rosidl_interface_packages</member_of_group>

Language: unknown
find_package(rosidl_default_generatorsREQUIRED)

Language: unknown
set(msg_files"msg/AddressBook.msg")

Language: unknown
rosidl_generate_interfaces(${PROJECT_NAME}${msg_files})

Language: unknown
ament_export_dependencies(rosidl_default_runtime)

Language: unknown
#include<chrono>#include<memory>#include"rclcpp/rclcpp.hpp"#include"more_interfaces/msg/address_book.hpp"usingnamespacestd::chrono_literals;classAddressBookPublisher:publicrclcpp::Node{public:AddressBookPublisher():Node("address_book_publisher"){address_book_publisher_=this->create_publisher<more_interfaces::msg::AddressBook>("address_book",10);autopublish_msg=[this]()->void{automessage=more_interfaces::msg::AddressBook();message.first_name="John";message.last_name="Doe";message.phone_number="1234567890";message.phone_type=message.PHONE_TYPE_MOBILE;std::cout<<"Publishing Contact\nFirst:"<<message.first_name<<"  Last:"<<message.last_name<<std::endl;this->address_book_publisher_->publish(message);};timer_=this->create_wall_timer(1s,publish_msg);}private:rclcpp::Publisher<more_interfaces::msg::AddressBook>::SharedPtraddress_book_publisher_;rclcpp::TimerBase::SharedPtrtimer_;};intmain(intargc,char*argv[]){rclcpp::init(argc,argv);rclcpp::spin(std::make_shared<AddressBookPublisher>());rclcpp::shutdown();return0;}

Language: unknown
#include"more_interfaces/msg/address_book.hpp"

Language: unknown
usingnamespacestd::chrono_literals;classAddressBookPublisher:publicrclcpp::Node{public:AddressBookPublisher():Node("address_book_publisher"){address_book_publisher_=this->create_publisher<more_interfaces::msg::AddressBook>("address_book");

Language: unknown
autopublish_msg=[this]()->void{

Language: unknown
automessage=more_interfaces::msg::AddressBook();

Language: unknown
message.first_name="John";message.last_name="Doe";message.phone_number="1234567890";message.phone_type=message.PHONE_TYPE_MOBILE;

Language: unknown
std::cout<<"Publishing Contact\nFirst:"<<message.first_name<<"  Last:"<<message.last_name<<std::endl;this->address_book_publisher_->publish(message);

Language: unknown
timer_=this->create_wall_timer(1s,publish_msg);

Language: unknown
find_package(rclcppREQUIRED)add_executable(publish_address_booksrc/publish_address_book.cpp)ament_target_dependencies(publish_address_bookrclcpp)install(TARGETSpublish_address_bookDESTINATIONlib/${PROJECT_NAME})

Language: unknown
rosidl_get_typesupport_target(cpp_typesupport_target${PROJECT_NAME}rosidl_typesupport_cpp)target_link_libraries(publish_address_book"${cpp_typesupport_target}")

Language: unknown
cd ~/ros2_wscolcon build --packages-up-to more_interfaces

Language: unknown
cd ~/ros2_wscolcon build --packages-up-to more_interfaces

Language: unknown
cd /ros2_wscolcon build --merge-install --packages-up-to more_interfaces

Language: unknown
source install/local_setup.bashros2 run more_interfaces publish_address_book

Language: unknown
. install/local_setup.bashros2 run more_interfaces publish_address_book

Language: unknown
call install/local_setup.batros2 run more_interfaces publish_address_book

Language: unknown
install/local_setup.ps1ros2 run more_interfaces publish_address_book

Language: unknown
source install/setup.bashros2 topic echo /address_book

Language: unknown
. install/setup.bashros2 topic echo /address_book

Language: unknown
call install/setup.batros2 topic echo /address_book

Language: unknown
install/setup.ps1ros2 topic echo /address_book

Language: unknown
rosidl_tutorials_msgs/Contact[]address_book

Language: unknown
<build_depend>rosidl_tutorials_msgs</build_depend><exec_depend>rosidl_tutorials_msgs</exec_depend>

Language: unknown
find_package(rosidl_tutorials_msgsREQUIRED)rosidl_generate_interfaces(${PROJECT_NAME}${msg_files}DEPENDENCIESrosidl_tutorials_msgs)

Language: unknown
#include"rosidl_tutorials_msgs/msg/contact.hpp"

Language: unknown
autopublish_msg=[this]()->void{automsg=std::make_shared<more_interfaces::msg::AddressBook>();{rosidl_tutorials_msgs::msg::Contactcontact;contact.first_name="John";contact.last_name="Doe";contact.phone_number="1234567890";contact.phone_type=message.PHONE_TYPE_MOBILE;msg->address_book.push_back(contact);}{rosidl_tutorials_msgs::msg::Contactcontact;contact.first_name="Jane";contact.last_name="Doe";contact.phone_number="4254242424";contact.phone_type=message.PHONE_TYPE_HOME;msg->address_book.push_back(contact);}std::cout<<"Publishing address book:"<<std::endl;for(autocontact:msg->address_book){std::cout<<"First:"<<contact.first_name<<"  Last:"<<contact.last_name<<std::endl;}address_book_publisher_->publish(*msg);};
