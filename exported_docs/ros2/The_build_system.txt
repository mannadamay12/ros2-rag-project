Title: The build system
URL: https://docs.ros.org/en/jazzy/Concepts/Advanced/About-Build-System.html
Section: Installation
--------------------------------------------------------------------------------

The build systemTable of ContentsBuild toolBuild helpersTheament_packagepackageTheament_cmakerepositoryTheament_lintrepositoryMeta-build toolThe build system is what allows developers to build their ROS 2 code as needed.
ROS 2 relies heavily on the division of code into packages, with each package containing a manifest file (package.xml).
This manifest file contains essential metadata about the package, including its dependencies on other packages.
This manifest is required for the meta-build tool to function.The ROS 2 build system consists of 3 major concepts.Build toolThis is the software that controls the compilation and testing of a single package.
In ROS 2 this is usually CMake for C++, and setuptools for Python, but other build tools are supported.Build helpersThese are helper functions that hook into the build tool to developer experience.
ROS 2 packages typically rely on theamentseries of packages for this.amentconsists of a few important repositories which are all in theGitHub organization.Theament_packagepackageLocated onGitHubatament/ament_package, this repository contains a singleament Python packagethat provides various utilities forament packages, e.g. templates for environment hooks.Allament packagesmust contain a singlepackage.xmlfile at the root of the package regardless of their underlying build system.
Thepackage.xml“manifest” file contains information that is required in order to process and operate on apackage.
Thispackageinformation includes things like thepackage’s name, which is globally unique, and the package’s dependencies.
Thepackage.xmlfile also serves as the marker file which indicates the location of thepackageon the file system.Parsing of thepackage.xmlfiles is provided bycatkin_pkg(as in ROS 1), while functionality to locatepackagesby searching the file system for thesepackage.xmlfiles is provided by build tools such ascolcon.package.xmlPackage manifest file which marks the root of apackageand contains meta information about thepackageincluding its name, version, description, maintainer, license, dependencies, and more.
The contents of the manifest are in machine readable XML format and the contents are described in theREPs127and140, with the possibility of further modifications in futureREPs.So anytime somepackageis referred to as anament package, it means that it is a single unit of software (source code, build files, tests, documentation, and other resources) which is described using apackage.xmlmanifest file.ament packageAnypackagewhich contains apackage.xmland follows the packaging guidelines ofament, regardless of the underlying build system.Since the termament packageis build system agnostic, there can be different kinds ofament packages, e.g.ament CMake package,ament Python package, etc.Here is a list of common package types that you might run into in this software stack:CMake packageAnypackagecontaining a plain CMake project and apackage.xmlmanifest file.ament CMake packageACMake packagethat also follows theamentpackaging guidelines.Python packageAnypackagecontaining asetuptoolsbased Python project and apackage.xmlmanifest file.ament Python packageAPython packagethat also follows theamentpackaging guidelines.Theament_cmakerepositoryLocated onGitHubatament/ament_cmake, this repository contains many “ament CMake” and pure CMake packages which provide the infrastructure in CMake that is required to create “ament CMake” packages.
In this context “ament CMake” packages means:amentpackages that are built using CMake.
So thepackagesin this repository provide the necessary CMake functions/macros and CMake Modules to facilitate creating more “ament CMake” (orament_cmake) packages.
Packages of this type are identified with the<build_type>ament_cmake</build_type>tag in the<export>tag of thepackage.xmlfile.Thepackagesin this repository are extremely modular, but there is a single “bottleneck”packagecalledament_cmake.
Anyone can depend on theament_cmakepackageto get all of the aggregate functionality of thepackagesin this repository.
Here a list of thepackagesin the repository along with a short description:ament_cmakeaggregates all otherpackagesin this repository, users need only to depend on thisament_cmake_autoprovides convenience CMake functions which automatically handle a lot of the tedious parts of writing apackage’sCMakeLists.txtfileament_cmake_coreprovides all built-in core concepts forament, e.g. environment hooks, resource indexing, symbolic linking install and othersament_cmake_gmockadds convenience functions for making gmock based unit testsament_cmake_gtestadds convenience functions for making gtest based automated testsament_cmake_noseadds convenience functions for making nosetests based python automated testsament_cmake_pythonprovides CMake functions forpackagesthat contain Python codesee theament_cmake_python user documentationament_cmake_testaggregates different kinds of tests, e.g. gtest and nosetests, under a single target usingCTestTheament_cmake_corepackagecontains a lot of the CMake infrastructure that makes it possible to cleanly pass information betweenpackagesusing conventional interfaces.
This makes thepackageshave more decoupled build interfaces with otherpackages, promoting their reuse and encouraging conventions in the build systems of differentpackages.
For instance, it provides a standard way to pass include directories, libraries, definitions, and dependencies betweenpackagesso that consumers of this information can access this information in a conventional way.Theament_cmake_corepackagealso provides features of theamentbuild system like symbolic link installation, which allows you to symbolically link files from either the source space or the build space into the install space rather than copying them.
This allows you to install once and then edit non-generated resources like Python code and configuration files without having to rerun the install step for them to take effect.
This feature essentially replaces the “devel space” fromcatkinbecause it has most of the advantages with few of the complications or drawbacks.Another feature provided byament_cmake_coreis thepackageresource indexing which is a way forpackagesto indicate that they contain a resource of some type.
The design of this feature makes it much more efficient to answer simple questions like whatpackagesare in this prefix (e.g./usr/local) because it only requires that you list the files in a single possible location under that prefix.
You can read more about this feature in thedesign docsfor the resource index.Likecatkin,ament_cmake_corealso provides environment setup files andpackagespecific environment hooks.
The environment setup files, often named something likesetup.bash, are a place forpackagedevelopers to define changes to the environment that are needed to utilize theirpackage.
The developers are able to do this using an “environment hook” which is basically an arbitrary bit of shell code that can set or modify environment variables, define shell functions, setup auto-completion rules, etc…
This feature is how, for example, ROS 1 set theROS_DISTROenvironment variable withoutcatkinknowing anything about the ROS distribution.Theament_lintrepositoryLocated onGitHubatament/ament_lint, this repository provides severalpackageswhich provide linting and testing services in a convenient and consistent manner.
Currently there arepackagesto support C++ style linting usinguncrustify, static C++ code checks usingcppcheck, checking for copyright in source code, Python style linting usingpep8, and other things.
The list of helper packages will likely grow in the future.Meta-build toolThis is a piece of software that knows how to topologically order a group of packages, and build or test them in the correct dependency order.
This software will call into the Build Tool to do the actual work of compiling, testing, and installing the package.In ROS 2, the tool namedcolconis used for this.