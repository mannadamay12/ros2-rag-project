Title: Implementing a custom memory allocator
URL: https://docs.ros.org/en/jazzy/Tutorials/Advanced/Allocator-Template-Tutorial.html
Section: Installation
--------------------------------------------------------------------------------

Implementing a custom memory allocatorGoal:This tutorial will show how to use a custom memory allocator when writing ROS 2 C++ code.Tutorial level:AdvancedTime:20 minutesTable of ContentsBackgroundWriting an allocatorWriting an example mainPassing an allocator to the intra-process pipelineTesting and verifying the codeThe TLSF allocatorThis tutorial will teach you how to integrate a custom allocator for publishers and subscribers so that the default heap allocator is never called while your ROS nodes are executing.
The code for this tutorial is availablehere.BackgroundSuppose you want to write real-time safe code, and you’ve heard about the many dangers of callingnewduring the real-time critical section, because the default heap allocator on most platforms is nondeterministic.By default, many C++ standard library structures will implicitly allocate memory as they grow, such asstd::vector.
However, these data structures also accept an “Allocator” template argument.
If you specify a custom allocator to one of these data structures, it will use that allocator instead of the system allocator to grow or shrink the data structure.
Your custom allocator could have a pool of memory preallocated on the stack, which might be better suited to real-time applications.In the ROS 2 C++ client library (rclcpp), we are following a similar philosophy to the C++ standard library.
Publishers, subscribers, and the Executor accept an Allocator template parameter that controls allocations made by that entity during execution.Writing an allocatorTo write an allocator compatible with ROS 2’s allocator interface, your allocator must be compatible with the C++ standard library allocator interface.Since C++17, the standard library provides something calledstd::pmr::memory_resource.
This is a class that can be derived from to create a custom allocator that fulfills a minimum set of requirements.For example, the following declaration for a custom memory resource fulfills the requirements (of course, you would still need to implement the declared functions in this class):classCustomMemoryResource:publicstd::pmr::memory_resource{private:void*do_allocate(std::size_tbytes,std::size_talignment)override;voiddo_deallocate(void*p,std::size_tbytes,std::size_talignment)override;booldo_is_equal(conststd::pmr::memory_resource&other)constnoexceptoverride;};To learn about the full capabilities ofstd::pmr::memory_resource, seehttps://en.cppreference.com/w/cpp/memory/memory_resource.The full implementation of the custom allocator for this tutorial is inhttps://github.com/ros2/demos/blob/jazzy/demo_nodes_cpp/src/topics/allocator_tutorial_pmr.cpp.Writing an example mainOnce you have written a valid C++ allocator, you must pass it as a shared pointer to your publisher, subscriber, and executor.
But first, we’ll declare a few aliases to shorten the names.usingrclcpp::memory_strategies::allocator_memory_strategy::AllocatorMemoryStrategy;usingAlloc=std::pmr::polymorphic_allocator<void>;usingMessageAllocTraits=rclcpp::allocator::AllocRebind<std_msgs::msg::UInt32,Alloc>;usingMessageAlloc=MessageAllocTraits::allocator_type;usingMessageDeleter=rclcpp::allocator::Deleter<MessageAlloc,std_msgs::msg::UInt32>;usingMessageUniquePtr=std::unique_ptr<std_msgs::msg::UInt32,MessageDeleter>;Now we can create our resources with the custom allocator:CustomMemoryResourcemem_resource{};autoalloc=std::make_shared<Alloc>(&mem_resource);rclcpp::PublisherOptionsWithAllocator<Alloc>publisher_options;publisher_options.allocator=alloc;autopublisher=node->create_publisher<std_msgs::msg::UInt32>("allocator_tutorial",10,publisher_options);rclcpp::SubscriptionOptionsWithAllocator<Alloc>subscription_options;subscription_options.allocator=alloc;automsg_mem_strat=std::make_shared<rclcpp::message_memory_strategy::MessageMemoryStrategy<std_msgs::msg::UInt32,Alloc>>(alloc);autosubscriber=node->create_subscription<std_msgs::msg::UInt32>("allocator_tutorial",10,callback,subscription_options,msg_mem_strat);std::shared_ptr<rclcpp::memory_strategy::MemoryStrategy>memory_strategy=std::make_shared<AllocatorMemoryStrategy<Alloc>>(alloc);rclcpp::ExecutorOptionsoptions;options.memory_strategy=memory_strategy;rclcpp::executors::SingleThreadedExecutorexecutor(options);You must also instantiate a custom deleter and allocator for use when allocating messages:MessageDeletermessage_deleter;MessageAllocmessage_alloc=*alloc;rclcpp::allocator::set_allocator_for_deleter(&message_deleter,&message_alloc);Once you’ve add the node to the executor, it is time to spin.
We’ll use the custom allocator to allocate each message:uint32_ti=0;while(rclcpp::ok()){autoptr=MessageAllocTraits::allocate(message_alloc,1);MessageAllocTraits::construct(message_alloc,ptr);MessageUniquePtrmsg(ptr,message_deleter);msg->data=i;++i;publisher->publish(std::move(msg));rclcpp::sleep_for(10ms);executor.spin_some();}Passing an allocator to the intra-process pipelineEven though we instantiated a publisher and subscriber in the same process, we aren’t using the intra-process pipeline yet.The IntraProcessManager is a class that is usually hidden from the user, but in order to pass a custom allocator to it we need to expose it by getting it from the rclcpp Context.
The IntraProcessManager makes use of several standard library structures, so without a custom allocator it will call the defaultnew.autocontext=rclcpp::contexts::get_global_default_context();autooptions=rclcpp::NodeOptions().context(context).use_intra_process_comms(true);autonode=rclcpp::Node::make_shared("allocator_example",options);Make sure to instantiate publishers and subscribers AFTER constructing the node in this way.Testing and verifying the codeHow do you know that your custom allocator is actually getting called?The obvious thing to do would be to count the calls made to your custom allocator’sallocateanddeallocatefunctions and compare that to the calls tonewanddelete.Adding counting to the custom allocator is easy:void*do_allocate(std::size_tsize,std::size_talignment)override{// ...num_allocs++;// ...}voiddo_deallocate(void*p,std::size_tbytes,std::size_talignment)override{// ...num_deallocs++;// ...}You can also override the globalnewanddeleteoperators:void*operatornew(std::size_tsize){if(is_running){global_runtime_allocs++;}returnstd::malloc(size);}voidoperatordelete(void*ptr,size_t)noexcept{if(ptr!=nullptr){if(is_running){global_runtime_deallocs++;}std::free(ptr);}}voidoperatordelete(void*ptr)noexcept{if(ptr!=nullptr){if(is_running){global_runtime_deallocs++;}std::free(ptr);}}where the variables we are incrementing are just global static integers, andis_runningis a global static boolean that gets toggled right before the call tospin.Theexample executableprints the value of the variables.
To run the example executable, use:ros2 run demo_nodes_cpp allocator_tutorialor, to run the example with the intra-process pipeline on:ros2 run demo_nodes_cpp allocator_tutorial intraYou should get numbers like:Global new was called 15590 times during spinGlobal delete was called 15590 times during spinAllocator new was called 27284 times during spinAllocator delete was called 27281 times during spinWe’ve caught about 2/3 of the allocations/deallocations that happen on the execution path, but where do the remaining 1/3 come from?As a matter of fact, these allocations/deallocations originate in the underlying DDS implementation used in this example.Proving this is out of the scope of this tutorial, but you can check out the test for the allocation path that gets run as part of the ROS 2 continuous integration testing, which backtraces through the code and figures out whether certain function calls originate in the rmw implementation or in a DDS implementation:https://github.com/ros2/realtime_support/blob/jazzy/tlsf_cpp/test/test_tlsf.cpp#L41Note that this test is not using the custom allocator we just created, but the TLSF allocator (see below).The TLSF allocatorROS 2 offers support for the TLSF (Two Level Segregate Fit) allocator, which was designed to meet real-time requirements:https://github.com/ros2/realtime_support/tree/jazzy/tlsf_cppFor more information about TLSF, seehttp://www.gii.upv.es/tlsf/Note that the TLSF allocator is licensed under a dual-GPL/LGPL license.A full working example using the TLSF allocator is here:https://github.com/ros2/realtime_support/blob/jazzy/tlsf_cpp/example/allocator_example.cpp

Code Examples:

Language: unknown
classCustomMemoryResource:publicstd::pmr::memory_resource{private:void*do_allocate(std::size_tbytes,std::size_talignment)override;voiddo_deallocate(void*p,std::size_tbytes,std::size_talignment)override;booldo_is_equal(conststd::pmr::memory_resource&other)constnoexceptoverride;};

Language: unknown
usingrclcpp::memory_strategies::allocator_memory_strategy::AllocatorMemoryStrategy;usingAlloc=std::pmr::polymorphic_allocator<void>;usingMessageAllocTraits=rclcpp::allocator::AllocRebind<std_msgs::msg::UInt32,Alloc>;usingMessageAlloc=MessageAllocTraits::allocator_type;usingMessageDeleter=rclcpp::allocator::Deleter<MessageAlloc,std_msgs::msg::UInt32>;usingMessageUniquePtr=std::unique_ptr<std_msgs::msg::UInt32,MessageDeleter>;

Language: unknown
CustomMemoryResourcemem_resource{};autoalloc=std::make_shared<Alloc>(&mem_resource);rclcpp::PublisherOptionsWithAllocator<Alloc>publisher_options;publisher_options.allocator=alloc;autopublisher=node->create_publisher<std_msgs::msg::UInt32>("allocator_tutorial",10,publisher_options);rclcpp::SubscriptionOptionsWithAllocator<Alloc>subscription_options;subscription_options.allocator=alloc;automsg_mem_strat=std::make_shared<rclcpp::message_memory_strategy::MessageMemoryStrategy<std_msgs::msg::UInt32,Alloc>>(alloc);autosubscriber=node->create_subscription<std_msgs::msg::UInt32>("allocator_tutorial",10,callback,subscription_options,msg_mem_strat);std::shared_ptr<rclcpp::memory_strategy::MemoryStrategy>memory_strategy=std::make_shared<AllocatorMemoryStrategy<Alloc>>(alloc);rclcpp::ExecutorOptionsoptions;options.memory_strategy=memory_strategy;rclcpp::executors::SingleThreadedExecutorexecutor(options);

Language: unknown
MessageDeletermessage_deleter;MessageAllocmessage_alloc=*alloc;rclcpp::allocator::set_allocator_for_deleter(&message_deleter,&message_alloc);

Language: unknown
uint32_ti=0;while(rclcpp::ok()){autoptr=MessageAllocTraits::allocate(message_alloc,1);MessageAllocTraits::construct(message_alloc,ptr);MessageUniquePtrmsg(ptr,message_deleter);msg->data=i;++i;publisher->publish(std::move(msg));rclcpp::sleep_for(10ms);executor.spin_some();}

Language: unknown
autocontext=rclcpp::contexts::get_global_default_context();autooptions=rclcpp::NodeOptions().context(context).use_intra_process_comms(true);autonode=rclcpp::Node::make_shared("allocator_example",options);

Language: unknown
void*do_allocate(std::size_tsize,std::size_talignment)override{// ...num_allocs++;// ...}voiddo_deallocate(void*p,std::size_tbytes,std::size_talignment)override{// ...num_deallocs++;// ...}

Language: unknown
void*operatornew(std::size_tsize){if(is_running){global_runtime_allocs++;}returnstd::malloc(size);}voidoperatordelete(void*ptr,size_t)noexcept{if(ptr!=nullptr){if(is_running){global_runtime_deallocs++;}std::free(ptr);}}voidoperatordelete(void*ptr)noexcept{if(ptr!=nullptr){if(is_running){global_runtime_deallocs++;}std::free(ptr);}}

Language: unknown
ros2 run demo_nodes_cpp allocator_tutorial

Language: unknown
ros2 run demo_nodes_cpp allocator_tutorial intra

Language: unknown
Global new was called 15590 times during spinGlobal delete was called 15590 times during spinAllocator new was called 27284 times during spinAllocator delete was called 27281 times during spin
