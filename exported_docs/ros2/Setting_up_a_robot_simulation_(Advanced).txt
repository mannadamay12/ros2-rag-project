Title: Setting up a robot simulation (Advanced)
URL: https://docs.ros.org/en/jazzy/Tutorials/Advanced/Simulators/Webots/Setting-Up-Simulation-Webots-Advanced.html
Section: Installation
--------------------------------------------------------------------------------

Setting up a robot simulation (Advanced)Goal:Extend a robot simulation with an obstacle avoider node.Tutorial level:AdvancedTime:20 minutesContentsBackgroundPrerequisitesTasks1 Updatingmy_robot.urdf2 Creating a ROS node to avoid obstacles3 Updating additional files4 Test the obstacle avoidance codeSummaryNext stepsBackgroundIn this tutorial you will extend the package created in the first part of the tutorial:Setting up a robot simulation (Basic).
The aim is to implement a ROS 2 node that avoids obstacles using the robot’s distance sensors.
This tutorial focuses on using robot devices with thewebots_ros2_driverinterface.PrerequisitesThis is a continuation of the first part of the tutorial:Setting up a robot simulation (Basic).
It is mandatory to start with the first part to set up the custom packages and necessary files.This tutorial is compatible with version 2023.1.0 ofwebots_ros2and Webots R2023b, as well as upcoming versions.Tasks1 Updatingmy_robot.urdfAs mentioned inSetting up a robot simulation (Basic),webots_ros2_drivercontains plugins to interface most of Webots devices with ROS 2 directly.
These plugins can be loaded using the<device>tag in the URDF file of the robot.
Thereferenceattribute should match the Webots devicenameparameter.
The list of all existing interfaces and the corresponding parameters can be foundon the devices reference page.
For available devices that are not configured in the URDF file, the interface will be automatically created and default values will be used for ROS parameters (e.g.updaterate,topicname, andframename).Inmy_robot.urdfreplace the whole contents with:PythonC++<?xml version="1.0" ?><robotname="My robot"><webots><devicereference="ds0"type="DistanceSensor"><ros><topicName>/left_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><devicereference="ds1"type="DistanceSensor"><ros><topicName>/right_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><plugintype="my_package.my_robot_driver.MyRobotDriver"/></webots></robot><?xml version="1.0" ?><robotname="My robot"><webots><devicereference="ds0"type="DistanceSensor"><ros><topicName>/left_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><devicereference="ds1"type="DistanceSensor"><ros><topicName>/right_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><plugintype="my_robot_driver::MyRobotDriver"/></webots></robot>In addition to your custom plugin, thewebots_ros2_driverwill parse the<device>tags referring to theDistanceSensornodes and use the standard parameters in the<ros>tags to enable the sensors and name their topics.2 Creating a ROS node to avoid obstaclesPythonC++The robot will use a standard ROS node to detect the wall and send motor commands to avoid it.
In themy_package/my_package/folder, create a file namedobstacle_avoider.pywith this code:importrclpyfromrclpy.nodeimportNodefromsensor_msgs.msgimportRangefromgeometry_msgs.msgimportTwistMAX_RANGE=0.15classObstacleAvoider(Node):def__init__(self):super().__init__('obstacle_avoider')self.__publisher=self.create_publisher(Twist,'cmd_vel',1)self.create_subscription(Range,'left_sensor',self.__left_sensor_callback,1)self.create_subscription(Range,'right_sensor',self.__right_sensor_callback,1)def__left_sensor_callback(self,message):self.__left_sensor_value=message.rangedef__right_sensor_callback(self,message):self.__right_sensor_value=message.rangecommand_message=Twist()command_message.linear.x=0.1ifself.__left_sensor_value<0.9*MAX_RANGEorself.__right_sensor_value<0.9*MAX_RANGE:command_message.angular.z=-2.0self.__publisher.publish(command_message)defmain(args=None):rclpy.init(args=args)avoider=ObstacleAvoider()rclpy.spin(avoider)# Destroy the node explicitly# (optional - otherwise it will be done automatically# when the garbage collector destroys the node object)avoider.destroy_node()rclpy.shutdown()if__name__=='__main__':main()This node will create a publisher for the command and subscribe to the sensors topics here:self.__publisher=self.create_publisher(Twist,'cmd_vel',1)self.create_subscription(Range,'left_sensor',self.__left_sensor_callback,1)self.create_subscription(Range,'right_sensor',self.__right_sensor_callback,1)When a measurement is received from the left sensor it will be copied to a member field:def__left_sensor_callback(self,message):self.__left_sensor_value=message.rangeFinally, a message will be sent to the/cmd_veltopic when a measurement from the right sensor is received.
Thecommand_messagewill register at least a forward speed inlinear.xin order to make the robot move when no obstacle is detected.
If any of the two sensors detect an obstacle,command_messagewill also register a rotational speed inangular.zin order to make the robot turn right.def__right_sensor_callback(self,message):self.__right_sensor_value=message.rangecommand_message=Twist()command_message.linear.x=0.1ifself.__left_sensor_value<0.9*MAX_RANGEorself.__right_sensor_value<0.9*MAX_RANGE:command_message.angular.z=-2.0self.__publisher.publish(command_message)The robot will use a standard ROS node to detect the wall and send motor commands to avoid it.
In themy_package/include/my_packagefolder, create a header file namedObstacleAvoider.hppwith this code:#include<memory>#include"geometry_msgs/msg/twist.hpp"#include"rclcpp/rclcpp.hpp"#include"sensor_msgs/msg/range.hpp"classObstacleAvoider:publicrclcpp::Node{public:explicitObstacleAvoider();private:voidleftSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg);voidrightSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg);rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtrpublisher_;rclcpp::Subscription<sensor_msgs::msg::Range>::SharedPtrleft_sensor_sub_;rclcpp::Subscription<sensor_msgs::msg::Range>::SharedPtrright_sensor_sub_;doubleleft_sensor_value{0.0};doubleright_sensor_value{0.0};};In themy_package/srcfolder, create a source file namedObstacleAvoider.cppwith this code:#include"my_package/ObstacleAvoider.hpp"#define MAX_RANGE 0.15ObstacleAvoider::ObstacleAvoider():Node("obstacle_avoider"){publisher_=create_publisher<geometry_msgs::msg::Twist>("/cmd_vel",1);left_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/left_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->leftSensorCallback(msg);});right_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/right_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->rightSensorCallback(msg);});}voidObstacleAvoider::leftSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){left_sensor_value=msg->range;}voidObstacleAvoider::rightSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){right_sensor_value=msg->range;autocommand_message=std::make_unique<geometry_msgs::msg::Twist>();command_message->linear.x=0.1;if(left_sensor_value<0.9*MAX_RANGE||right_sensor_value<0.9*MAX_RANGE){command_message->angular.z=-2.0;}publisher_->publish(std::move(command_message));}intmain(intargc,char*argv[]){rclcpp::init(argc,argv);autoavoider=std::make_shared<ObstacleAvoider>();rclcpp::spin(avoider);rclcpp::shutdown();return0;}This node will create a publisher for the command and subscribe to the sensors topics here:publisher_=create_publisher<geometry_msgs::msg::Twist>("/cmd_vel",1);left_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/left_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->leftSensorCallback(msg);});right_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/right_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->rightSensorCallback(msg);});When a measurement is received from the left sensor it will be copied to a member field:voidObstacleAvoider::leftSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){left_sensor_value=msg->range;}Finally, a message will be sent to the/cmd_veltopic when a measurement from the right sensor is received.
Thecommand_messagewill register at least a forward speed inlinear.xin order to make the robot move when no obstacle is detected.
If any of the two sensors detect an obstacle,command_messagewill also register a rotational speed inangular.zin order to make the robot turn right.voidObstacleAvoider::rightSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){right_sensor_value=msg->range;autocommand_message=std::make_unique<geometry_msgs::msg::Twist>();command_message->linear.x=0.1;if(left_sensor_value<0.9*MAX_RANGE||right_sensor_value<0.9*MAX_RANGE){command_message->angular.z=-2.0;}publisher_->publish(std::move(command_message));}3 Updating additional filesYou have to modify these two other files to launch your new node.PythonC++Editsetup.pyand replace'console_scripts'with:'console_scripts':['my_robot_driver = my_package.my_robot_driver:main','obstacle_avoider = my_package.obstacle_avoider:main'],This will add an entry point for theobstacle_avoidernode.EditCMakeLists.txtand add the compilation and installation of theobstacle_avoider:cmake_minimum_required(VERSION3.5)project(my_package)if(NOTCMAKE_CXX_STANDARD)set(CMAKE_CXX_STANDARD14)endif()# Besides the package specific dependencies we also need the `pluginlib` and `webots_ros2_driver`find_package(ament_cmakeREQUIRED)find_package(rclcppREQUIRED)find_package(std_msgsREQUIRED)find_package(geometry_msgsREQUIRED)find_package(pluginlibREQUIRED)find_package(webots_ros2_driverREQUIRED)# Export the plugin configuration filepluginlib_export_plugin_description_file(webots_ros2_drivermy_robot_driver.xml)# Obstacle avoiderinclude_directories(include)add_executable(obstacle_avoidersrc/ObstacleAvoider.cpp)ament_target_dependencies(obstacle_avoiderrclcppgeometry_msgssensor_msgs)install(TARGETSobstacle_avoiderDESTINATIONlib/${PROJECT_NAME})install(DIRECTORYinclude/DESTINATIONinclude)# MyRobotDriver libraryadd_library(${PROJECT_NAME}SHAREDsrc/MyRobotDriver.cpp)target_include_directories(${PROJECT_NAME}PRIVATEinclude)ament_target_dependencies(${PROJECT_NAME}pluginlibrclcppwebots_ros2_driver)install(TARGETS${PROJECT_NAME}ARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)# Install additional directories.install(DIRECTORYlaunchresourceworldsDESTINATIONshare/${PROJECT_NAME}/)ament_export_include_directories(include)ament_export_libraries(${PROJECT_NAME})ament_package()Go to the filerobot_launch.pyand replace it with:importosimportlaunchfromlaunch_ros.actionsimportNodefromlaunchimportLaunchDescriptionfromament_index_python.packagesimportget_package_share_directoryfromwebots_ros2_driver.webots_launcherimportWebotsLauncherfromwebots_ros2_driver.webots_controllerimportWebotsControllerdefgenerate_launch_description():package_dir=get_package_share_directory('my_package')robot_description_path=os.path.join(package_dir,'resource','my_robot.urdf')webots=WebotsLauncher(world=os.path.join(package_dir,'worlds','my_world.wbt'))my_robot_driver=WebotsController(robot_name='my_robot',parameters=[{'robot_description':robot_description_path},])obstacle_avoider=Node(package='my_package',executable='obstacle_avoider',)returnLaunchDescription([webots,my_robot_driver,obstacle_avoider,launch.actions.RegisterEventHandler(event_handler=launch.event_handlers.OnProcessExit(target_action=webots,on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],))])This will create anobstacle_avoidernode that will be included in theLaunchDescription.4 Test the obstacle avoidance codeLaunch the simulation from a terminal in your ROS 2 workspace:LinuxWindowsmacOSFrom a terminal in your ROS 2 workspace run:colcon buildsource install/local_setup.bashros2 launch my_package robot_launch.pyFrom a terminal in your WSL ROS 2 workspace run:colcon buildexport WEBOTS_HOME=/mnt/c/Program\ Files/Webotssource install/local_setup.bashros2 launch my_package robot_launch.pyBe sure to use the/mntprefix in front of your path to the Webots installation folder to access the Windows file system from WSL.In a terminal of the host machine (not in the VM), if not done already, specify the Webots installation folder (e.g./Applications/Webots.app) and start the server using the following commands:export WEBOTS_HOME=/Applications/Webots.apppython3 local_simulation_server.pyNote that the server keeps running once the ROS 2 nodes are ended.
You don’t need to restart it every time you want to launch a new simulation.
From a terminal in the Linux VM in your ROS 2 workspace, build and launch your custom package with:cd ~/ros2_wscolcon buildsource install/local_setup.bashros2 launch my_package robot_launch.pyYour robot should go forward and before hitting the wall it should turn clockwise.
You can pressCtrl+F10in Webots or go to theViewmenu,OptionalRenderingandShowDistanceSensorRaysto display the range of the distance sensors of the robot.SummaryIn this tutorial, you extended the basic simulation with a obstacle avoider ROS 2 node that publishes velocity commands based on the distance sensor values of the robot.Next stepsYou might want to improve the plugin or create new nodes to change the behavior of the robot.
You can also implement a reset handler to automatically restart your ROS nodes when the simulation is reset from the Webots interface:Setting up a Reset Handler.

Code Examples:

Language: unknown
<?xml version="1.0" ?><robotname="My robot"><webots><devicereference="ds0"type="DistanceSensor"><ros><topicName>/left_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><devicereference="ds1"type="DistanceSensor"><ros><topicName>/right_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><plugintype="my_package.my_robot_driver.MyRobotDriver"/></webots></robot>

Language: unknown
<?xml version="1.0" ?><robotname="My robot"><webots><devicereference="ds0"type="DistanceSensor"><ros><topicName>/left_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><devicereference="ds1"type="DistanceSensor"><ros><topicName>/right_sensor</topicName><alwaysOn>true</alwaysOn></ros></device><plugintype="my_robot_driver::MyRobotDriver"/></webots></robot>

Language: unknown
importrclpyfromrclpy.nodeimportNodefromsensor_msgs.msgimportRangefromgeometry_msgs.msgimportTwistMAX_RANGE=0.15classObstacleAvoider(Node):def__init__(self):super().__init__('obstacle_avoider')self.__publisher=self.create_publisher(Twist,'cmd_vel',1)self.create_subscription(Range,'left_sensor',self.__left_sensor_callback,1)self.create_subscription(Range,'right_sensor',self.__right_sensor_callback,1)def__left_sensor_callback(self,message):self.__left_sensor_value=message.rangedef__right_sensor_callback(self,message):self.__right_sensor_value=message.rangecommand_message=Twist()command_message.linear.x=0.1ifself.__left_sensor_value<0.9*MAX_RANGEorself.__right_sensor_value<0.9*MAX_RANGE:command_message.angular.z=-2.0self.__publisher.publish(command_message)defmain(args=None):rclpy.init(args=args)avoider=ObstacleAvoider()rclpy.spin(avoider)# Destroy the node explicitly# (optional - otherwise it will be done automatically# when the garbage collector destroys the node object)avoider.destroy_node()rclpy.shutdown()if__name__=='__main__':main()

Language: unknown
self.__publisher=self.create_publisher(Twist,'cmd_vel',1)self.create_subscription(Range,'left_sensor',self.__left_sensor_callback,1)self.create_subscription(Range,'right_sensor',self.__right_sensor_callback,1)

Language: unknown
def__left_sensor_callback(self,message):self.__left_sensor_value=message.range

Language: unknown
def__right_sensor_callback(self,message):self.__right_sensor_value=message.rangecommand_message=Twist()command_message.linear.x=0.1ifself.__left_sensor_value<0.9*MAX_RANGEorself.__right_sensor_value<0.9*MAX_RANGE:command_message.angular.z=-2.0self.__publisher.publish(command_message)

Language: unknown
#include<memory>#include"geometry_msgs/msg/twist.hpp"#include"rclcpp/rclcpp.hpp"#include"sensor_msgs/msg/range.hpp"classObstacleAvoider:publicrclcpp::Node{public:explicitObstacleAvoider();private:voidleftSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg);voidrightSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg);rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtrpublisher_;rclcpp::Subscription<sensor_msgs::msg::Range>::SharedPtrleft_sensor_sub_;rclcpp::Subscription<sensor_msgs::msg::Range>::SharedPtrright_sensor_sub_;doubleleft_sensor_value{0.0};doubleright_sensor_value{0.0};};

Language: unknown
#include"my_package/ObstacleAvoider.hpp"#define MAX_RANGE 0.15ObstacleAvoider::ObstacleAvoider():Node("obstacle_avoider"){publisher_=create_publisher<geometry_msgs::msg::Twist>("/cmd_vel",1);left_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/left_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->leftSensorCallback(msg);});right_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/right_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->rightSensorCallback(msg);});}voidObstacleAvoider::leftSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){left_sensor_value=msg->range;}voidObstacleAvoider::rightSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){right_sensor_value=msg->range;autocommand_message=std::make_unique<geometry_msgs::msg::Twist>();command_message->linear.x=0.1;if(left_sensor_value<0.9*MAX_RANGE||right_sensor_value<0.9*MAX_RANGE){command_message->angular.z=-2.0;}publisher_->publish(std::move(command_message));}intmain(intargc,char*argv[]){rclcpp::init(argc,argv);autoavoider=std::make_shared<ObstacleAvoider>();rclcpp::spin(avoider);rclcpp::shutdown();return0;}

Language: unknown
publisher_=create_publisher<geometry_msgs::msg::Twist>("/cmd_vel",1);left_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/left_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->leftSensorCallback(msg);});right_sensor_sub_=create_subscription<sensor_msgs::msg::Range>("/right_sensor",1,[this](constsensor_msgs::msg::Range::SharedPtrmsg){returnthis->rightSensorCallback(msg);});

Language: unknown
voidObstacleAvoider::leftSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){left_sensor_value=msg->range;}

Language: unknown
voidObstacleAvoider::rightSensorCallback(constsensor_msgs::msg::Range::SharedPtrmsg){right_sensor_value=msg->range;autocommand_message=std::make_unique<geometry_msgs::msg::Twist>();command_message->linear.x=0.1;if(left_sensor_value<0.9*MAX_RANGE||right_sensor_value<0.9*MAX_RANGE){command_message->angular.z=-2.0;}publisher_->publish(std::move(command_message));}

Language: unknown
'console_scripts':['my_robot_driver = my_package.my_robot_driver:main','obstacle_avoider = my_package.obstacle_avoider:main'],

Language: unknown
cmake_minimum_required(VERSION3.5)project(my_package)if(NOTCMAKE_CXX_STANDARD)set(CMAKE_CXX_STANDARD14)endif()# Besides the package specific dependencies we also need the `pluginlib` and `webots_ros2_driver`find_package(ament_cmakeREQUIRED)find_package(rclcppREQUIRED)find_package(std_msgsREQUIRED)find_package(geometry_msgsREQUIRED)find_package(pluginlibREQUIRED)find_package(webots_ros2_driverREQUIRED)# Export the plugin configuration filepluginlib_export_plugin_description_file(webots_ros2_drivermy_robot_driver.xml)# Obstacle avoiderinclude_directories(include)add_executable(obstacle_avoidersrc/ObstacleAvoider.cpp)ament_target_dependencies(obstacle_avoiderrclcppgeometry_msgssensor_msgs)install(TARGETSobstacle_avoiderDESTINATIONlib/${PROJECT_NAME})install(DIRECTORYinclude/DESTINATIONinclude)# MyRobotDriver libraryadd_library(${PROJECT_NAME}SHAREDsrc/MyRobotDriver.cpp)target_include_directories(${PROJECT_NAME}PRIVATEinclude)ament_target_dependencies(${PROJECT_NAME}pluginlibrclcppwebots_ros2_driver)install(TARGETS${PROJECT_NAME}ARCHIVEDESTINATIONlibLIBRARYDESTINATIONlibRUNTIMEDESTINATIONbin)# Install additional directories.install(DIRECTORYlaunchresourceworldsDESTINATIONshare/${PROJECT_NAME}/)ament_export_include_directories(include)ament_export_libraries(${PROJECT_NAME})ament_package()

Language: unknown
importosimportlaunchfromlaunch_ros.actionsimportNodefromlaunchimportLaunchDescriptionfromament_index_python.packagesimportget_package_share_directoryfromwebots_ros2_driver.webots_launcherimportWebotsLauncherfromwebots_ros2_driver.webots_controllerimportWebotsControllerdefgenerate_launch_description():package_dir=get_package_share_directory('my_package')robot_description_path=os.path.join(package_dir,'resource','my_robot.urdf')webots=WebotsLauncher(world=os.path.join(package_dir,'worlds','my_world.wbt'))my_robot_driver=WebotsController(robot_name='my_robot',parameters=[{'robot_description':robot_description_path},])obstacle_avoider=Node(package='my_package',executable='obstacle_avoider',)returnLaunchDescription([webots,my_robot_driver,obstacle_avoider,launch.actions.RegisterEventHandler(event_handler=launch.event_handlers.OnProcessExit(target_action=webots,on_exit=[launch.actions.EmitEvent(event=launch.events.Shutdown())],))])

Language: unknown
colcon buildsource install/local_setup.bashros2 launch my_package robot_launch.py

Language: unknown
colcon buildexport WEBOTS_HOME=/mnt/c/Program\ Files/Webotssource install/local_setup.bashros2 launch my_package robot_launch.py

Language: unknown
export WEBOTS_HOME=/Applications/Webots.apppython3 local_simulation_server.py

Language: unknown
cd ~/ros2_wscolcon buildsource install/local_setup.bashros2 launch my_package robot_launch.py
