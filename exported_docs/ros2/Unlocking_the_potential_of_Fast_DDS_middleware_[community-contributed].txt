Title: Unlocking the potential of Fast DDS middleware [community-contributed]
URL: https://docs.ros.org/en/jazzy/Tutorials/Advanced/FastDDS-Configuration.html
Section: Installation
--------------------------------------------------------------------------------

Unlocking the potential of Fast DDS middleware [community-contributed]Goal:This tutorial will show how to use the extended configuration capabilities of Fast DDS in ROS 2.Tutorial level:AdvancedTime:20 minutesTable of ContentsBackgroundPrerequisitesMixing synchronous and asynchronous publications in the same nodeCreate the node with the publishersCreate the XML file with the profile configurationExecute the publisher nodeCreate a node with the subscribersExecute the subscriber nodeAnalysis of the exampleUsing other FastDDS capabilities with XMLLimiting the number of matching subscribersUsing partitions within the topicConfiguring a service and a clientCreate the nodes with the service and clientCreate the XML profiles for the service and clientExecute the nodesBackgroundThe interface between the ROS 2 stack andFast DDSis provided by the ROS 2 middleware implementationrmw_fastrtps.
This implementation is available in all ROS 2 distributions, both from binaries and from sources.ROS 2 RMW only allows for the configuration of certain middleware QoS
(seeROS 2 QoS policies).
However,rmw_fastrtpsoffers extended configuration capabilities to take full advantage of the features inFast DDS.
This tutorial will guide you through a series of examples explaining how to use XML files to unlock this extended configuration.In order to get more information about usingFast DDSon ROS 2, please check thefollowing documentation.PrerequisitesThis tutorial assumes that you know how tocreate a package.
It also assumes you know how to write asimple publisher and subscriberand asimple service and client.
Although the examples are implemented in C++, the same concepts apply to Python packages.Mixing synchronous and asynchronous publications in the same nodeIn this first example, a node with two publishers, one of them with synchronous publication mode and the other one with asynchronous publication mode, will be created.rmw_fastrtpsuses synchronous publication mode by default.With synchronous publication mode the data is sent directly within the context of the user thread.
This entails that any blocking call occurring during the write operation would block the user thread, thus preventing the application from continuing its operation.
However, this mode typically yields higher throughput rates at lower latencies, since there is no notification nor context switching between threads.On the other hand, with asynchronous publication mode, each time the publisher invokes the write operation, the data is copied into a queue,
a background thread (asynchronous thread) is notified about the addition to the queue, and control of the thread is returned to the user before the data is actually sent.
The background thread is in charge of consuming the queue and sending the data to every matched reader.Create the node with the publishersFirst, create a new package namedsync_async_node_example_cppon a new workspace:LinuxmacOSWindowsmkdir -p ~/ros2_ws/srccd ~/ros2_ws/srcros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cppmkdir -p ~/ros2_ws/srccd ~/ros2_ws/srcros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cppmd \ros2_ws\srccd \ros2_ws\srcros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cppThen, add a file namedsrc/sync_async_writer.cppto the package, with the following content.
Note that the synchronous publisher will be publishing on topicsync_topic, while the asynchronous one will be publishing on topicasync_topic.#include<chrono>#include<functional>#include<memory>#include<string>#include"rclcpp/rclcpp.hpp"#include"std_msgs/msg/string.hpp"usingnamespacestd::chrono_literals;classSyncAsyncPublisher:publicrclcpp::Node{public:SyncAsyncPublisher():Node("sync_async_publisher"),count_(0){// Create the synchronous publisher on topic 'sync_topic'sync_publisher_=this->create_publisher<std_msgs::msg::String>("sync_topic",10);// Create the asynchronous publisher on topic 'async_topic'async_publisher_=this->create_publisher<std_msgs::msg::String>("async_topic",10);// Actions to run every time the timer expiresautotimer_callback=[this](){// Create a new message to be sentautosync_message=std_msgs::msg::String();sync_message.data="SYNC: Hello, world! "+std::to_string(count_);// Log the message to the console to show progressRCLCPP_INFO(this->get_logger(),"Synchronously publishing: '%s'",sync_message.data.c_str());// Publish the message using the synchronous publishersync_publisher_->publish(sync_message);// Create a new message to be sentautoasync_message=std_msgs::msg::String();async_message.data="ASYNC: Hello, world! "+std::to_string(count_);// Log the message to the console to show progressRCLCPP_INFO(this->get_logger(),"Asynchronously publishing: '%s'",async_message.data.c_str());// Publish the message using the asynchronous publisherasync_publisher_->publish(async_message);// Prepare the count for the next messagecount_++;};// This timer will trigger the publication of new data every half a secondtimer_=this->create_wall_timer(500ms,timer_callback);}private:// This timer will trigger the publication of new data every half a secondrclcpp::TimerBase::SharedPtrtimer_;// A publisher that publishes asynchronouslyrclcpp::Publisher<std_msgs::msg::String>::SharedPtrasync_publisher_;// A publisher that publishes synchronouslyrclcpp::Publisher<std_msgs::msg::String>::SharedPtrsync_publisher_;// Number of messages sent so farsize_tcount_;};intmain(intargc,char*argv[]){rclcpp::init(argc,argv);rclcpp::spin(std::make_shared<SyncAsyncPublisher>());rclcpp::shutdown();return0;}Now open theCMakeLists.txtfile and add a new executable and name itSyncAsyncWriterso you can run your node usingros2run:add_executable(SyncAsyncWritersrc/sync_async_writer.cpp)ament_target_dependencies(SyncAsyncWriterrclcppstd_msgs)Finally, add theinstall(TARGETS…)section soros2runcan find your executable:install(TARGETSSyncAsyncWriterDESTINATIONlib/${PROJECT_NAME})You can clean up yourCMakeLists.txtby removing some unnecessary sections and comments, so it looks like this:cmake_minimum_required(VERSION3.8)project(sync_async_node_example_cpp)# Default to C++14if(NOTCMAKE_CXX_STANDARD)set(CMAKE_CXX_STANDARD14)endif()if(CMAKE_COMPILER_IS_GNUCXXORCMAKE_CXX_COMPILER_IDMATCHES"Clang")add_compile_options(-Wall-Wextra-Wpedantic)endif()find_package(ament_cmakeREQUIRED)find_package(rclcppREQUIRED)find_package(std_msgsREQUIRED)add_executable(SyncAsyncWritersrc/sync_async_writer.cpp)ament_target_dependencies(SyncAsyncWriterrclcppstd_msgs)install(TARGETSSyncAsyncWriterDESTINATIONlib/${PROJECT_NAME})ament_package()If this node is built and run now, both publishers will behave the same, publishing asynchronously in both topics, because this is the default publication mode.
The default publication mode configuration can be changed in runtime during the node launching, using an XML file.Create the XML file with the profile configurationCreate a file with nameSyncAsync.xmland the following content:<?xml version="1.0" encoding="UTF-8" ?><profilesxmlns="http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles"><!-- default publisher profile --><publisherprofile_name="default_publisher"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></publisher><!-- default subscriber profile --><subscriberprofile_name="default_subscriber"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></subscriber><!-- publisher profile for topic sync_topic --><publisherprofile_name="/sync_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>SYNCHRONOUS</kind></publishMode></qos></publisher><!-- publisher profile for topic async_topic --><publisherprofile_name="/async_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>ASYNCHRONOUS</kind></publishMode></qos></publisher></profiles>Note that several profiles for publisher and subscriber are defined.
Two default profiles which are defined setting theis_default_profiletotrue, and two profiles with names that coincide with those of the previously defined topics:sync_topicand another one forasync_topic.
These last two profiles set the publication mode toSYNCHRONOUSorASYNCHRONOUSaccordingly.
Note also that all profiles specify ahistoryMemoryPolicyvalue, which is needed for the example to work, and the reason will be explained later on this tutorial.Execute the publisher nodeYou will need to export the following environment variables for the XML to be loaded:LinuxmacOSWindowsexport RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xmlexport RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xmlSET RMW_IMPLEMENTATION=rmw_fastrtps_cppSET RMW_FASTRTPS_USE_QOS_FROM_XML=1SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xmlFinally, ensure you have sourced your setup files and run the node:source install/setup.bashros2 run sync_async_node_example_cpp SyncAsyncWriterYou should see the publishers sending the data from the publishing node, like so:[INFO] [1612972049.994630332] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 0'[INFO] [1612972049.995097767] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 0'[INFO] [1612972050.494478706] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 1'[INFO] [1612972050.494664334] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 1'[INFO] [1612972050.994368474] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 2'[INFO] [1612972050.994549851] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 2'Now you have a synchronous publisher and an asynchronous publisher running inside the same node.Create a node with the subscribersNext, a new node with the subscribers that will listen to thesync_topicandasync_topicpublications is going to be created.
In a new source file namedsrc/sync_async_reader.cppwrite the following content:#include<memory>#include"rclcpp/rclcpp.hpp"#include"std_msgs/msg/string.hpp"classSyncAsyncSubscriber:publicrclcpp::Node{public:SyncAsyncSubscriber():Node("sync_async_subscriber"){// Lambda function to run every time a new message is receivedautotopic_callback=[this](conststd_msgs::msg::String&msg){RCLCPP_INFO(this->get_logger(),"I heard: '%s'",msg.data.c_str());};// Create the synchronous subscriber on topic 'sync_topic'// and tie it to the topic_callbacksync_subscription_=this->create_subscription<std_msgs::msg::String>("sync_topic",10,topic_callback);// Create the asynchronous subscriber on topic 'async_topic'// and tie it to the topic_callbackasync_subscription_=this->create_subscription<std_msgs::msg::String>("async_topic",10,topic_callback);}private:// A subscriber that listens to topic 'sync_topic'rclcpp::Subscription<std_msgs::msg::String>::SharedPtrsync_subscription_;// A subscriber that listens to topic 'async_topic'rclcpp::Subscription<std_msgs::msg::String>::SharedPtrasync_subscription_;};intmain(intargc,char*argv[]){rclcpp::init(argc,argv);rclcpp::spin(std::make_shared<SyncAsyncSubscriber>());rclcpp::shutdown();return0;}Open theCMakeLists.txtfile and add a new executable and name itSyncAsyncReaderunder the previousSyncAsyncWriter:add_executable(SyncAsyncReadersrc/sync_async_reader.cpp)ament_target_dependencies(SyncAsyncReaderrclcppstd_msgs)install(TARGETSSyncAsyncReaderDESTINATIONlib/${PROJECT_NAME})Execute the subscriber nodeWith the publisher node running in one terminal, open another one and export the required environment variables for the XML to be loaded:LinuxmacOSWindowsexport RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xmlexport RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xmlSET RMW_IMPLEMENTATION=rmw_fastrtps_cppSET RMW_FASTRTPS_USE_QOS_FROM_XML=1SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xmlFinally, ensure you have sourced your setup files and run the node:source install/setup.bashros2 run sync_async_node_example_cpp SyncAsyncReaderYou should see the subscribers receiving the data from the publishing node, like so:[INFO] [1612972054.495429090] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 10'[INFO] [1612972054.995410057] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 10'[INFO] [1612972055.495453494] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 11'[INFO] [1612972055.995396561] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 11'[INFO] [1612972056.495534818] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 12'[INFO] [1612972056.995473953] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 12'Analysis of the exampleConfiguration profiles XMLThe XML file defines several configurations for publishers and subscribers.
You can have a default publisher configuration profile and several topic-specific publisher profiles.
The only requirement is that all publisher profiles have a different name and that there is only a single default profile.
The same goes for subscribers.In order to define a configuration for a specific topic, just name the profile after the the ROS 2 topic name (like/sync_topicand/async_topicin the example),
andrmw_fastrtpswill apply this profile to all publishers and subscribers for that topic.
The default configuration profile is identified by the attributeis_default_profileset totrue, and acts as a fallback profile when there is no other one with a name matching the topic name.The environment variableFASTRTPS_DEFAULT_PROFILES_FILEis used to informFast DDSthe path to the XML file with the configuration profiles to load.RMW_FASTRTPS_USE_QOS_FROM_XMLAmong all the configurable attributes,rmw_fastrtpstreatspublishModeandhistoryMemoryPolicydifferently.
By default, these values are set toASYNCHRONOUSandPREALLOCATED_WITH_REALLOCwithin thermw_fastrtpsimplementation, and the values set on the XML file are ignored.
In order to use the values in the XML file, the environment variableRMW_FASTRTPS_USE_QOS_FROM_XMLmust be set to1.However, this entailsanother caveat: IfRMW_FASTRTPS_USE_QOS_FROM_XMLis set, but the XML file does not definepublishModeorhistoryMemoryPolicy, these attributes take theFast DDSdefault value instead of thermw_fastrtpsdefault value.
This is important, especially forhistoryMemoryPolicy, because theFast DDSdeafult value isPREALLOCATEDwhich does not work with ROS2 topic data types.
Therefore, in the example, a valid value for this policy has been explicitly set (DYNAMIC).Prioritization of rmw_qos_profile_tROS 2 QoS contained inrmw_qos_profile_tare always honored, unless set to*_SYSTEM_DEFAULT.
In that case, XML values (orFast DDSdefault values in the absence of XML ones) are applied.
This means that if any QoS inrmw_qos_profile_tis set to something other than*_SYSTEM_DEFAULT, the corresponding value in the XML is ignored.Using other FastDDS capabilities with XMLAlthough we have created a node with two publishers with different configuration, it is not easy to check that they are behaving differently.
Now that the basics of XML profiles have been covered, let us use them to configure something which has some visual effect on the nodes.
Specifically, a maximum number of matching subscribers on one of the publishers and a partition definition on the other will be set.
Note that these are only very simple examples among all the configuration attributes that can be tuned onrmw_fastrtpsthrough XML files.
Please refer to*Fast DDS* documentationto  see the whole list of attributes that can be configured through XML files.Limiting the number of matching subscribersAdd a maximum number of matched subscribers to the/async_topicpublisher profile.
It should look like this:<!-- publisher profile for topic async_topic --><publisherprofile_name="/async_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>ASYNCHRONOUS</kind></publishMode></qos><matchedSubscribersAllocation><initial>0</initial><maximum>1</maximum><increment>1</increment></matchedSubscribersAllocation></publisher>The number of matching subscribers is being limited to one.Now open three terminals and do not forget to source the setup files and to set the required environment variables.
On the first terminal run the publisher node, and the subscriber node on the other two.
You should see that only the first subscriber node receives the messages from both topics.
The second one could not complete the matching process in the/async_topicbecause the publisher prevented it, as it had already reached its maximum of matched publishers.
Consequently, only the messages from the/sync_topicare going to be received in this third terminal:[INFO] [1613127657.088860890] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 18'[INFO] [1613127657.588896594] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 19'[INFO] [1613127658.088849401] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 20'Using partitions within the topicThe partitions feature can be used to control which publishers and subscribers exchange information within the same topic.Partitions introduce a logical entity isolation level concept inside the physical isolation induced by a Domain ID.
For a publisher to communicate with a subscriber, they have to belong at least to one common partition.
Partitions represent another level to separate publishers and subscribers beyond domain and topic.
Unlike domain and topic, an endpoint can belong to several partitions at the same time.
For certain data to be shared over different domains or topics, there must be a different publisher for each, sharing its own history of changes.
However, a single publisher can share the same data sample over different partitions using a single topic data change, thus reducing network overload.Let us change the/sync_topicpublisher to partitionpart1and create a new/sync_topicsubscriber which uses partitionpart2.
Their profiles should now look like this:<!-- publisher profile for topic sync_topic --><publisherprofile_name="/sync_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>SYNCHRONOUS</kind></publishMode><partition><names><name>part1</name></names></partition></qos></publisher><!-- subscriber profile for topic sync_topic --><subscriberprofile_name="/sync_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><partition><names><name>part2</name></names></partition></qos></subscriber>Open two terminals.
Do not forget to source the setup files and to set the required environment variables.
On the first terminal run the publisher node, and the subscriber node on the other one.
You should see that only the/async_topicmessages are reaching the subscriber.
The/sync_topicsubscriber is not receiving the data as it is in a different partition from the corresponding publisher.[INFO] [1612972054.995410057] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 10'[INFO] [1612972055.995396561] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 11'[INFO] [1612972056.995473953] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 12'Configuring a service and a clientServices and clients have a publisher and a subscriber each, that communicate through two different topics.
For example, for a service namedpingthere is:A service subscriber listening to requests on/rq/ping.A service publisher sending responses on/rr/ping.A client publisher sending requests on/rq/ping.A client subscriber listening to responses on/rr/ping.Although you can use these topic names to set the configuration profiles on the XML, sometimes you may wish to apply the same profile to all services or clients on a node.
Instead of copying the same profile with all topic names generated for all services, you can just create a publisher and subscriber profile pair namedservice.
The same can be done for clients creating a pair namedclient.Create the nodes with the service and clientStart creating the node with the service.
Add a new source file namedsrc/ping_service.cppon your package with the following content:#include<memory>#include"rclcpp/rclcpp.hpp"#include"example_interfaces/srv/trigger.hpp"/*** Service action: responds with success=true and prints the request on the console*/voidping(conststd::shared_ptr<example_interfaces::srv::Trigger::Request>request,std::shared_ptr<example_interfaces::srv::Trigger::Response>response){// The request data is unused(void)request;// Build the responseresponse->success=true;// Log to the consoleRCLCPP_INFO(rclcpp::get_logger("ping_server"),"Incoming request");RCLCPP_INFO(rclcpp::get_logger("ping_server"),"Sending back response");}intmain(intargc,char**argv){rclcpp::init(argc,argv);// Create the node and the servicestd::shared_ptr<rclcpp::Node>node=rclcpp::Node::make_shared("ping_server");rclcpp::Service<example_interfaces::srv::Trigger>::SharedPtrservice=node->create_service<example_interfaces::srv::Trigger>("ping",&ping);// Log that the service is readyRCLCPP_INFO(rclcpp::get_logger("ping_server"),"Ready to serve.");// run the noderclcpp::spin(node);rclcpp::shutdown();}Create the client in a file namedsrc/ping_client.cppwith the following content:#include<chrono>#include<memory>#include"rclcpp/rclcpp.hpp"#include"example_interfaces/srv/trigger.hpp"usingnamespacestd::chrono_literals;intmain(intargc,char**argv){rclcpp::init(argc,argv);// Create the node and the clientstd::shared_ptr<rclcpp::Node>node=rclcpp::Node::make_shared("ping_client");rclcpp::Client<example_interfaces::srv::Trigger>::SharedPtrclient=node->create_client<example_interfaces::srv::Trigger>("ping");// Create a requestautorequest=std::make_shared<example_interfaces::srv::Trigger::Request>();// Wait for the service to be availablewhile(!client->wait_for_service(1s)){if(!rclcpp::ok()){RCLCPP_ERROR(rclcpp::get_logger("ping_client"),"Interrupted while waiting for the service. Exiting.");return0;}RCLCPP_INFO(rclcpp::get_logger("ping_client"),"Service not available, waiting again...");}// Now that the service is available, send the requestRCLCPP_INFO(rclcpp::get_logger("ping_client"),"Sending request");autoresult=client->async_send_request(request);// Wait for the result and log it to the consoleif(rclcpp::spin_until_future_complete(node,result)==rclcpp::FutureReturnCode::SUCCESS){RCLCPP_INFO(rclcpp::get_logger("ping_client"),"Response received");}else{RCLCPP_ERROR(rclcpp::get_logger("ping_client"),"Failed to call service ping");}rclcpp::shutdown();return0;}Open theCMakeLists.txtfile and add two new executablesping_serviceandping_client:find_package(example_interfacesREQUIRED)add_executable(ping_servicesrc/ping_service.cpp)ament_target_dependencies(ping_serviceexample_interfacesrclcpp)add_executable(ping_clientsrc/ping_client.cpp)ament_target_dependencies(ping_clientexample_interfacesrclcpp)install(TARGETSping_serviceDESTINATIONlib/${PROJECT_NAME})install(TARGETSping_clientDESTINATIONlib/${PROJECT_NAME})Finally, build the package.Create the XML profiles for the service and clientCreate a file with nameping.xmlwith the following content:<?xml version="1.0" encoding="UTF-8" ?><profilesxmlns="http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles"><!-- default publisher profile --><publisherprofile_name="default_publisher"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></publisher><!-- default subscriber profile --><subscriberprofile_name="default_subscriber"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></subscriber><!-- service publisher is SYNC --><publisherprofile_name="service"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>SYNCHRONOUS</kind></publishMode></qos></publisher><!-- client publisher is ASYNC --><publisherprofile_name="client"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>ASYNCHRONOUS</kind></publishMode></qos></publisher></profiles>This configuration file sets the publication mode toSYNCHRONOUSon the service and toASYNCHRONOUSon the client.
Note that we are only defining the publisher profiles for both the service and the client, but subscriber profiles could be provided too.Execute the nodesOpen two terminals and source the setup files on each one.
Then set the required environment variables for the XML to be loaded:LinuxmacOSWindowsexport RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xmlexport RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xmlSET RMW_IMPLEMENTATION=rmw_fastrtps_cppSET RMW_FASTRTPS_USE_QOS_FROM_XML=1SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xmlOn the first terminal run the service node.ros2 run sync_async_node_example_cpp ping_serviceYou should see the service waiting for requests:[INFO] [1612977403.805799037] [ping_server]: Ready to serve.On the second terminal, run the client node.ros2 run sync_async_node_example_cpp ping_clientYou should see the client sending the request and receiving the response:[INFO] [1612977404.805799037] [ping_client]: Sending request[INFO] [1612977404.825473835] [ping_client]: Response receivedAt the same time, the output in the server console has been updated:[INFO] [1612977403.805799037] [ping_server]: Ready to serve.[INFO] [1612977404.807314904] [ping_server]: Incoming request[INFO] [1612977404.836405125] [ping_server]: Sending back response

Code Examples:

Language: unknown
mkdir -p ~/ros2_ws/srccd ~/ros2_ws/srcros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cpp

Language: unknown
mkdir -p ~/ros2_ws/srccd ~/ros2_ws/srcros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cpp

Language: unknown
md \ros2_ws\srccd \ros2_ws\srcros2 pkg create --build-type ament_cmake --license Apache-2.0 --dependencies rclcpp std_msgs -- sync_async_node_example_cpp

Language: unknown
#include<chrono>#include<functional>#include<memory>#include<string>#include"rclcpp/rclcpp.hpp"#include"std_msgs/msg/string.hpp"usingnamespacestd::chrono_literals;classSyncAsyncPublisher:publicrclcpp::Node{public:SyncAsyncPublisher():Node("sync_async_publisher"),count_(0){// Create the synchronous publisher on topic 'sync_topic'sync_publisher_=this->create_publisher<std_msgs::msg::String>("sync_topic",10);// Create the asynchronous publisher on topic 'async_topic'async_publisher_=this->create_publisher<std_msgs::msg::String>("async_topic",10);// Actions to run every time the timer expiresautotimer_callback=[this](){// Create a new message to be sentautosync_message=std_msgs::msg::String();sync_message.data="SYNC: Hello, world! "+std::to_string(count_);// Log the message to the console to show progressRCLCPP_INFO(this->get_logger(),"Synchronously publishing: '%s'",sync_message.data.c_str());// Publish the message using the synchronous publishersync_publisher_->publish(sync_message);// Create a new message to be sentautoasync_message=std_msgs::msg::String();async_message.data="ASYNC: Hello, world! "+std::to_string(count_);// Log the message to the console to show progressRCLCPP_INFO(this->get_logger(),"Asynchronously publishing: '%s'",async_message.data.c_str());// Publish the message using the asynchronous publisherasync_publisher_->publish(async_message);// Prepare the count for the next messagecount_++;};// This timer will trigger the publication of new data every half a secondtimer_=this->create_wall_timer(500ms,timer_callback);}private:// This timer will trigger the publication of new data every half a secondrclcpp::TimerBase::SharedPtrtimer_;// A publisher that publishes asynchronouslyrclcpp::Publisher<std_msgs::msg::String>::SharedPtrasync_publisher_;// A publisher that publishes synchronouslyrclcpp::Publisher<std_msgs::msg::String>::SharedPtrsync_publisher_;// Number of messages sent so farsize_tcount_;};intmain(intargc,char*argv[]){rclcpp::init(argc,argv);rclcpp::spin(std::make_shared<SyncAsyncPublisher>());rclcpp::shutdown();return0;}

Language: unknown
add_executable(SyncAsyncWritersrc/sync_async_writer.cpp)ament_target_dependencies(SyncAsyncWriterrclcppstd_msgs)

Language: unknown
install(TARGETSSyncAsyncWriterDESTINATIONlib/${PROJECT_NAME})

Language: unknown
cmake_minimum_required(VERSION3.8)project(sync_async_node_example_cpp)# Default to C++14if(NOTCMAKE_CXX_STANDARD)set(CMAKE_CXX_STANDARD14)endif()if(CMAKE_COMPILER_IS_GNUCXXORCMAKE_CXX_COMPILER_IDMATCHES"Clang")add_compile_options(-Wall-Wextra-Wpedantic)endif()find_package(ament_cmakeREQUIRED)find_package(rclcppREQUIRED)find_package(std_msgsREQUIRED)add_executable(SyncAsyncWritersrc/sync_async_writer.cpp)ament_target_dependencies(SyncAsyncWriterrclcppstd_msgs)install(TARGETSSyncAsyncWriterDESTINATIONlib/${PROJECT_NAME})ament_package()

Language: unknown
<?xml version="1.0" encoding="UTF-8" ?><profilesxmlns="http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles"><!-- default publisher profile --><publisherprofile_name="default_publisher"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></publisher><!-- default subscriber profile --><subscriberprofile_name="default_subscriber"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></subscriber><!-- publisher profile for topic sync_topic --><publisherprofile_name="/sync_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>SYNCHRONOUS</kind></publishMode></qos></publisher><!-- publisher profile for topic async_topic --><publisherprofile_name="/async_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>ASYNCHRONOUS</kind></publishMode></qos></publisher></profiles>

Language: unknown
export RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Language: unknown
export RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Language: unknown
SET RMW_IMPLEMENTATION=rmw_fastrtps_cppSET RMW_FASTRTPS_USE_QOS_FROM_XML=1SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Language: unknown
source install/setup.bashros2 run sync_async_node_example_cpp SyncAsyncWriter

Language: unknown
[INFO] [1612972049.994630332] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 0'[INFO] [1612972049.995097767] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 0'[INFO] [1612972050.494478706] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 1'[INFO] [1612972050.494664334] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 1'[INFO] [1612972050.994368474] [sync_async_publisher]: Synchronously publishing: 'SYNC: Hello, world! 2'[INFO] [1612972050.994549851] [sync_async_publisher]: Asynchronously publishing: 'ASYNC: Hello, world! 2'

Language: unknown
#include<memory>#include"rclcpp/rclcpp.hpp"#include"std_msgs/msg/string.hpp"classSyncAsyncSubscriber:publicrclcpp::Node{public:SyncAsyncSubscriber():Node("sync_async_subscriber"){// Lambda function to run every time a new message is receivedautotopic_callback=[this](conststd_msgs::msg::String&msg){RCLCPP_INFO(this->get_logger(),"I heard: '%s'",msg.data.c_str());};// Create the synchronous subscriber on topic 'sync_topic'// and tie it to the topic_callbacksync_subscription_=this->create_subscription<std_msgs::msg::String>("sync_topic",10,topic_callback);// Create the asynchronous subscriber on topic 'async_topic'// and tie it to the topic_callbackasync_subscription_=this->create_subscription<std_msgs::msg::String>("async_topic",10,topic_callback);}private:// A subscriber that listens to topic 'sync_topic'rclcpp::Subscription<std_msgs::msg::String>::SharedPtrsync_subscription_;// A subscriber that listens to topic 'async_topic'rclcpp::Subscription<std_msgs::msg::String>::SharedPtrasync_subscription_;};intmain(intargc,char*argv[]){rclcpp::init(argc,argv);rclcpp::spin(std::make_shared<SyncAsyncSubscriber>());rclcpp::shutdown();return0;}

Language: unknown
add_executable(SyncAsyncReadersrc/sync_async_reader.cpp)ament_target_dependencies(SyncAsyncReaderrclcppstd_msgs)install(TARGETSSyncAsyncReaderDESTINATIONlib/${PROJECT_NAME})

Language: unknown
export RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Language: unknown
export RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Language: unknown
SET RMW_IMPLEMENTATION=rmw_fastrtps_cppSET RMW_FASTRTPS_USE_QOS_FROM_XML=1SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/SyncAsync.xml

Language: unknown
source install/setup.bashros2 run sync_async_node_example_cpp SyncAsyncReader

Language: unknown
[INFO] [1612972054.495429090] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 10'[INFO] [1612972054.995410057] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 10'[INFO] [1612972055.495453494] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 11'[INFO] [1612972055.995396561] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 11'[INFO] [1612972056.495534818] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 12'[INFO] [1612972056.995473953] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 12'

Language: unknown
<!-- publisher profile for topic async_topic --><publisherprofile_name="/async_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>ASYNCHRONOUS</kind></publishMode></qos><matchedSubscribersAllocation><initial>0</initial><maximum>1</maximum><increment>1</increment></matchedSubscribersAllocation></publisher>

Language: unknown
[INFO] [1613127657.088860890] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 18'[INFO] [1613127657.588896594] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 19'[INFO] [1613127658.088849401] [sync_async_subscriber]: I heard: 'SYNC: Hello, world! 20'

Language: unknown
<!-- publisher profile for topic sync_topic --><publisherprofile_name="/sync_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>SYNCHRONOUS</kind></publishMode><partition><names><name>part1</name></names></partition></qos></publisher><!-- subscriber profile for topic sync_topic --><subscriberprofile_name="/sync_topic"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><partition><names><name>part2</name></names></partition></qos></subscriber>

Language: unknown
[INFO] [1612972054.995410057] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 10'[INFO] [1612972055.995396561] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 11'[INFO] [1612972056.995473953] [sync_async_subscriber]: I heard: 'ASYNC: Hello, world! 12'

Language: unknown
#include<memory>#include"rclcpp/rclcpp.hpp"#include"example_interfaces/srv/trigger.hpp"/*** Service action: responds with success=true and prints the request on the console*/voidping(conststd::shared_ptr<example_interfaces::srv::Trigger::Request>request,std::shared_ptr<example_interfaces::srv::Trigger::Response>response){// The request data is unused(void)request;// Build the responseresponse->success=true;// Log to the consoleRCLCPP_INFO(rclcpp::get_logger("ping_server"),"Incoming request");RCLCPP_INFO(rclcpp::get_logger("ping_server"),"Sending back response");}intmain(intargc,char**argv){rclcpp::init(argc,argv);// Create the node and the servicestd::shared_ptr<rclcpp::Node>node=rclcpp::Node::make_shared("ping_server");rclcpp::Service<example_interfaces::srv::Trigger>::SharedPtrservice=node->create_service<example_interfaces::srv::Trigger>("ping",&ping);// Log that the service is readyRCLCPP_INFO(rclcpp::get_logger("ping_server"),"Ready to serve.");// run the noderclcpp::spin(node);rclcpp::shutdown();}

Language: unknown
#include<chrono>#include<memory>#include"rclcpp/rclcpp.hpp"#include"example_interfaces/srv/trigger.hpp"usingnamespacestd::chrono_literals;intmain(intargc,char**argv){rclcpp::init(argc,argv);// Create the node and the clientstd::shared_ptr<rclcpp::Node>node=rclcpp::Node::make_shared("ping_client");rclcpp::Client<example_interfaces::srv::Trigger>::SharedPtrclient=node->create_client<example_interfaces::srv::Trigger>("ping");// Create a requestautorequest=std::make_shared<example_interfaces::srv::Trigger::Request>();// Wait for the service to be availablewhile(!client->wait_for_service(1s)){if(!rclcpp::ok()){RCLCPP_ERROR(rclcpp::get_logger("ping_client"),"Interrupted while waiting for the service. Exiting.");return0;}RCLCPP_INFO(rclcpp::get_logger("ping_client"),"Service not available, waiting again...");}// Now that the service is available, send the requestRCLCPP_INFO(rclcpp::get_logger("ping_client"),"Sending request");autoresult=client->async_send_request(request);// Wait for the result and log it to the consoleif(rclcpp::spin_until_future_complete(node,result)==rclcpp::FutureReturnCode::SUCCESS){RCLCPP_INFO(rclcpp::get_logger("ping_client"),"Response received");}else{RCLCPP_ERROR(rclcpp::get_logger("ping_client"),"Failed to call service ping");}rclcpp::shutdown();return0;}

Language: unknown
find_package(example_interfacesREQUIRED)add_executable(ping_servicesrc/ping_service.cpp)ament_target_dependencies(ping_serviceexample_interfacesrclcpp)add_executable(ping_clientsrc/ping_client.cpp)ament_target_dependencies(ping_clientexample_interfacesrclcpp)install(TARGETSping_serviceDESTINATIONlib/${PROJECT_NAME})install(TARGETSping_clientDESTINATIONlib/${PROJECT_NAME})

Language: unknown
<?xml version="1.0" encoding="UTF-8" ?><profilesxmlns="http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles"><!-- default publisher profile --><publisherprofile_name="default_publisher"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></publisher><!-- default subscriber profile --><subscriberprofile_name="default_subscriber"is_default_profile="true"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy></subscriber><!-- service publisher is SYNC --><publisherprofile_name="service"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>SYNCHRONOUS</kind></publishMode></qos></publisher><!-- client publisher is ASYNC --><publisherprofile_name="client"><historyMemoryPolicy>DYNAMIC</historyMemoryPolicy><qos><publishMode><kind>ASYNCHRONOUS</kind></publishMode></qos></publisher></profiles>

Language: unknown
export RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xml

Language: unknown
export RMW_IMPLEMENTATION=rmw_fastrtps_cppexport RMW_FASTRTPS_USE_QOS_FROM_XML=1export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xml

Language: unknown
SET RMW_IMPLEMENTATION=rmw_fastrtps_cppSET RMW_FASTRTPS_USE_QOS_FROM_XML=1SET FASTRTPS_DEFAULT_PROFILES_FILE=path/to/ping.xml

Language: unknown
ros2 run sync_async_node_example_cpp ping_service

Language: unknown
[INFO] [1612977403.805799037] [ping_server]: Ready to serve.

Language: unknown
ros2 run sync_async_node_example_cpp ping_client

Language: unknown
[INFO] [1612977404.805799037] [ping_client]: Sending request[INFO] [1612977404.825473835] [ping_client]: Response received

Language: unknown
[INFO] [1612977403.805799037] [ping_server]: Ready to serve.[INFO] [1612977404.807314904] [ping_server]: Incoming request[INFO] [1612977404.836405125] [ping_server]: Sending back response
